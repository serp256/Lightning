diff -urN ocaml-4.02.1-clean/Makefile ocaml-4.02.1-ios/Makefile
--- ocaml-4.02.1-clean/Makefile	2014-09-24 05:12:13.000000000 +0400
+++ ocaml-4.02.1-ios/Makefile	2014-10-29 12:47:20.000000000 +0300
@@ -15,18 +15,18 @@
 include config/Makefile
 include stdlib/StdlibModules
 
-CAMLC=boot/ocamlrun boot/ocamlc -nostdlib -I boot
-CAMLOPT=boot/ocamlrun ./ocamlopt -nostdlib -I stdlib -I otherlibs/dynlink
+CAMLC=ocamlc.opt -I boot
+CAMLOPT=ocamlopt.opt
 COMPFLAGS=-strict-sequence -w +33..39+48 -warn-error A -bin-annot \
           -safe-string $(INCLUDES)
 LINKFLAGS=
 
-CAMLYACC=boot/ocamlyacc
+CAMLYACC=ocamlyacc
 YACCFLAGS=-v
-CAMLLEX=boot/ocamlrun boot/ocamllex
-CAMLDEP=boot/ocamlrun tools/ocamldep
+CAMLLEX=ocamllex.opt
+CAMLDEP=ocamldep.opt
 DEPFLAGS=$(INCLUDES)
-CAMLRUN=byterun/ocamlrun
+CAMLRUN=ocamlrun
 SHELL=/bin/sh
 MKDIR=mkdir -p
 
@@ -113,14 +113,7 @@
 
 PERVASIVES=$(STDLIB_MODULES) outcometree topdirs toploop
 
-# For users who don't read the INSTALL file
-defaultentry:
-	@echo "Please refer to the installation instructions in file INSTALL."
-	@echo "If you've just unpacked the distribution, something like"
-	@echo "	./configure"
-	@echo "	make world.opt"
-	@echo "	make install"
-	@echo "should work.  But see the file INSTALL for more details."
+defaultentry: runtime runtimeopt ocamlopt.opt libraryopt otherlibrariesopt 
 
 # Recompile the system using the bootstrap compiler
 all:
@@ -307,6 +300,37 @@
 	  else $(MKDIR) $(INSTALL_STUBLIBDIR); fi
 	if test -d $(INSTALL_COMPLIBDIR); then : ; \
 	  else $(MKDIR) $(INSTALL_COMPLIBDIR); fi
+	cp VERSION $(INSTALL_LIBDIR)/
+	cd byterun; $(MAKE) installopt
+	cd asmrun; $(MAKE) install
+	cp ocamlopt.opt $(INSTALL_BINDIR)/ocamlopt.opt$(EXE)
+	ln -fs $(INSTALL_BINDIR)/ocamlopt.opt $(BINDIR)/ocamlopt
+	cd stdlib; $(MAKE) installopt
+	for i in $(OTHERLIBRARIES); do \
+	  (cd otherlibs/$$i; $(MAKE) installopt) || exit $$?; \
+	done
+	cp asmcomp/*.cmi $(INSTALL_COMPLIBDIR)
+	cp compilerlibs/ocamlcommon.cmxa compilerlibs/ocamlcommon.a \
+           compilerlibs/ocamloptcomp.cmxa compilerlibs/ocamloptcomp.a \
+           $(OPTSTART:.cmo=.cmx) $(OPTSTART:.cmo=.o) \
+           $(INSTALL_COMPLIBDIR)
+	cd $(INSTALL_COMPLIBDIR) && $(RANLIB) ocamlcommon.a ocamloptcomp.a
+	cd ocamldoc; $(MAKE) installopt
+	for i in $(OTHERLIBRARIES); \
+	  do (cd otherlibs/$$i; $(MAKE) installopt) || exit $$?; done
+	cp tools/ocamlmklib $(INSTALL_BINDIR)
+	cp config/Makefile $(INSTALL_LIBDIR)/Makefile.config
+
+
+installall:
+	if test -d $(INSTALL_BINDIR); then : ; \
+	  else $(INSTALL_MKDIR) $(BINDIR); fi
+	if test -d $(INSTALL_LIBDIR); then : ; \
+	  else $(INSTALL_MKDIR) $(LIBDIR); fi
+	if test -d $(INSTALL_STUBLIBDIR); then : ; \
+	  else $(INSTALL_MKDIR) $(STUBLIBDIR); fi
+	if test -d $(INSTALL_COMPLIBDIR); then : ; \
+	  else $(INSTALL_MKDIR) $(COMPLIBDIR); fi
 	if test -d $(INSTALL_MANDIR)/man$(MANEXT); then : ; \
 	  else $(MKDIR) $(INSTALL_MANDIR)/man$(MANEXT); fi
 	cp VERSION $(INSTALL_LIBDIR)/
@@ -629,7 +653,7 @@
 
 tools/cvt_emit: tools/cvt_emit.mll
 	cd tools; \
-	$(MAKE) CAMLC="../$(CAMLRUN) ../boot/ocamlc -I ../stdlib" cvt_emit
+	$(MAKE) CAMLC="ocamlc" cvt_emit
 
 # The "expunge" utility
 
@@ -717,6 +741,9 @@
 ocamltoolsopt: ocamlopt
 	cd tools; $(MAKE) opt
 
+ocamlmklib:
+	cd tools; $(MAKE) ocamlmklib
+
 ocamltoolsopt.opt: ocamlc.opt ocamlyacc ocamllex asmcomp/cmx_format.cmi \
                    asmcomp/printclambda.cmx
 	cd tools; $(MAKE) opt.opt
@@ -754,7 +781,7 @@
 	  (cd otherlibs/$$i; $(MAKE) RUNTIME=$(RUNTIME) all) || exit $$?; \
 	done
 
-otherlibrariesopt:
+otherlibrariesopt: ocamlmklib
 	for i in $(OTHERLIBRARIES); do \
 	  (cd otherlibs/$$i; $(MAKE) allopt) || exit $$?; \
 	done
diff -urN ocaml-4.02.1-clean/Makefile.orig ocaml-4.02.1-ios/Makefile.orig
--- ocaml-4.02.1-clean/Makefile.orig	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.02.1-ios/Makefile.orig	2014-09-24 05:12:13.000000000 +0400
@@ -0,0 +1,869 @@
+#########################################################################
+#                                                                       #
+#                                 OCaml                                 #
+#                                                                       #
+#            Xavier Leroy, projet Cristal, INRIA Rocquencourt           #
+#                                                                       #
+#   Copyright 1999 Institut National de Recherche en Informatique et    #
+#   en Automatique.  All rights reserved.  This file is distributed     #
+#   under the terms of the Q Public License version 1.0.                #
+#                                                                       #
+#########################################################################
+
+# The main Makefile
+
+include config/Makefile
+include stdlib/StdlibModules
+
+CAMLC=boot/ocamlrun boot/ocamlc -nostdlib -I boot
+CAMLOPT=boot/ocamlrun ./ocamlopt -nostdlib -I stdlib -I otherlibs/dynlink
+COMPFLAGS=-strict-sequence -w +33..39+48 -warn-error A -bin-annot \
+          -safe-string $(INCLUDES)
+LINKFLAGS=
+
+CAMLYACC=boot/ocamlyacc
+YACCFLAGS=-v
+CAMLLEX=boot/ocamlrun boot/ocamllex
+CAMLDEP=boot/ocamlrun tools/ocamldep
+DEPFLAGS=$(INCLUDES)
+CAMLRUN=byterun/ocamlrun
+SHELL=/bin/sh
+MKDIR=mkdir -p
+
+OCAMLBUILDBYTE=$(WITH_OCAMLBUILD:=.byte)
+OCAMLBUILDNATIVE=$(WITH_OCAMLBUILD:=.native)
+
+OCAMLDOC_OPT=$(WITH_OCAMLDOC:=.opt)
+
+INCLUDES=-I utils -I parsing -I typing -I bytecomp -I asmcomp -I driver \
+	 -I toplevel
+
+UTILS=utils/misc.cmo utils/tbl.cmo utils/config.cmo \
+  utils/clflags.cmo utils/terminfo.cmo utils/ccomp.cmo utils/warnings.cmo \
+  utils/consistbl.cmo
+
+PARSING=parsing/location.cmo parsing/longident.cmo \
+  parsing/ast_helper.cmo \
+  parsing/syntaxerr.cmo parsing/parser.cmo \
+  parsing/lexer.cmo parsing/parse.cmo parsing/printast.cmo \
+  parsing/pprintast.cmo \
+  parsing/ast_mapper.cmo
+
+TYPING=typing/ident.cmo typing/path.cmo \
+  typing/primitive.cmo typing/types.cmo \
+  typing/btype.cmo typing/oprint.cmo \
+  typing/subst.cmo typing/predef.cmo \
+  typing/datarepr.cmo typing/cmi_format.cmo typing/env.cmo \
+  typing/typedtree.cmo typing/printtyped.cmo typing/ctype.cmo \
+  typing/printtyp.cmo typing/includeclass.cmo \
+  typing/mtype.cmo typing/envaux.cmo typing/includecore.cmo \
+  typing/typedtreeIter.cmo typing/typedtreeMap.cmo typing/cmt_format.cmo \
+  typing/includemod.cmo typing/typetexp.cmo typing/parmatch.cmo \
+  typing/stypes.cmo typing/typecore.cmo \
+  typing/typedecl.cmo typing/typeclass.cmo \
+  typing/typemod.cmo
+
+COMP=bytecomp/lambda.cmo bytecomp/printlambda.cmo \
+  bytecomp/typeopt.cmo bytecomp/switch.cmo bytecomp/matching.cmo \
+  bytecomp/translobj.cmo bytecomp/translcore.cmo \
+  bytecomp/translclass.cmo bytecomp/translmod.cmo \
+  bytecomp/simplif.cmo bytecomp/runtimedef.cmo \
+  driver/pparse.cmo driver/main_args.cmo \
+  driver/compenv.cmo driver/compmisc.cmo
+
+COMMON=$(UTILS) $(PARSING) $(TYPING) $(COMP)
+
+BYTECOMP=bytecomp/meta.cmo bytecomp/instruct.cmo bytecomp/bytegen.cmo \
+  bytecomp/printinstr.cmo bytecomp/opcodes.cmo bytecomp/emitcode.cmo \
+  bytecomp/bytesections.cmo bytecomp/dll.cmo bytecomp/symtable.cmo \
+  bytecomp/bytelink.cmo bytecomp/bytelibrarian.cmo bytecomp/bytepackager.cmo \
+  driver/errors.cmo driver/compile.cmo
+
+ASMCOMP=asmcomp/arch.cmo asmcomp/debuginfo.cmo \
+  asmcomp/cmm.cmo asmcomp/printcmm.cmo \
+  asmcomp/reg.cmo asmcomp/mach.cmo asmcomp/proc.cmo \
+  asmcomp/clambda.cmo asmcomp/printclambda.cmo asmcomp/compilenv.cmo \
+  asmcomp/closure.cmo asmcomp/strmatch.cmo asmcomp/cmmgen.cmo \
+  asmcomp/printmach.cmo asmcomp/selectgen.cmo asmcomp/selection.cmo \
+  asmcomp/comballoc.cmo \
+  asmcomp/CSEgen.cmo asmcomp/CSE.cmo \
+  asmcomp/liveness.cmo \
+  asmcomp/spill.cmo asmcomp/split.cmo \
+  asmcomp/interf.cmo asmcomp/coloring.cmo \
+  asmcomp/reloadgen.cmo asmcomp/reload.cmo \
+  asmcomp/deadcode.cmo \
+  asmcomp/printlinear.cmo asmcomp/linearize.cmo \
+  asmcomp/schedgen.cmo asmcomp/scheduling.cmo \
+  asmcomp/emitaux.cmo asmcomp/emit.cmo asmcomp/asmgen.cmo \
+  asmcomp/asmlink.cmo asmcomp/asmlibrarian.cmo asmcomp/asmpackager.cmo \
+  driver/opterrors.cmo driver/optcompile.cmo
+
+TOPLEVEL=toplevel/genprintval.cmo toplevel/toploop.cmo \
+  toplevel/trace.cmo toplevel/topdirs.cmo toplevel/topmain.cmo
+
+BYTESTART=driver/main.cmo
+
+OPTSTART=driver/optmain.cmo
+
+TOPLEVELSTART=toplevel/topstart.cmo
+
+NATTOPOBJS=$(UTILS) $(PARSING) $(TYPING) $(COMP) $(ASMCOMP) \
+  toplevel/genprintval.cmo toplevel/opttoploop.cmo toplevel/opttopdirs.cmo \
+  toplevel/opttopmain.cmo toplevel/opttopstart.cmo
+
+PERVASIVES=$(STDLIB_MODULES) outcometree topdirs toploop
+
+# For users who don't read the INSTALL file
+defaultentry:
+	@echo "Please refer to the installation instructions in file INSTALL."
+	@echo "If you've just unpacked the distribution, something like"
+	@echo "	./configure"
+	@echo "	make world.opt"
+	@echo "	make install"
+	@echo "should work.  But see the file INSTALL for more details."
+
+# Recompile the system using the bootstrap compiler
+all:
+	$(MAKE) runtime
+	$(MAKE) coreall
+	$(MAKE) ocaml
+	$(MAKE) otherlibraries $(OCAMLBUILDBYTE) $(WITH_DEBUGGER) \
+	  $(WITH_OCAMLDOC)
+
+# Compile everything the first time
+world:
+	$(MAKE) coldstart
+	$(MAKE) all
+
+# Compile also native code compiler and libraries, fast
+world.opt:
+	$(MAKE) coldstart
+	$(MAKE) opt.opt
+
+# Hard bootstrap how-to:
+# (only necessary in some cases, for example if you remove some primitive)
+#
+# make coreboot     [old system -- you were in a stable state]
+# <change the source>
+# make clean runtime coreall
+# <debug your changes>
+# make clean runtime coreall
+# make coreboot [new system -- now in a stable state]
+
+# Core bootstrapping cycle
+coreboot:
+# Save the original bootstrap compiler
+	$(MAKE) backup
+# Promote the new compiler but keep the old runtime
+# This compiler runs on boot/ocamlrun and produces bytecode for
+# byterun/ocamlrun
+	$(MAKE) promote-cross
+# Rebuild ocamlc and ocamllex (run on byterun/ocamlrun)
+	$(MAKE) partialclean
+	$(MAKE) ocamlc ocamllex ocamltools
+# Rebuild the library (using byterun/ocamlrun ./ocamlc)
+	$(MAKE) library-cross
+# Promote the new compiler and the new runtime
+	$(MAKE) promote
+# Rebuild the core system
+	$(MAKE) partialclean
+	$(MAKE) core
+# Check if fixpoint reached
+	$(MAKE) compare
+
+# Bootstrap and rebuild the whole system.
+# The compilation of ocaml will fail if the runtime has changed.
+# Never mind, just do make bootstrap to reach fixpoint again.
+bootstrap:
+	$(MAKE) coreboot
+	$(MAKE) all
+	$(MAKE) compare
+
+LIBFILES=stdlib.cma std_exit.cmo *.cmi camlheader
+
+# Start up the system from the distribution compiler
+coldstart:
+	cd byterun; $(MAKE) all
+	cp byterun/ocamlrun$(EXE) boot/ocamlrun$(EXE)
+	cd yacc; $(MAKE) all
+	cp yacc/ocamlyacc$(EXE) boot/ocamlyacc$(EXE)
+	cd stdlib; $(MAKE) COMPILER=../boot/ocamlc all
+	cd stdlib; cp $(LIBFILES) ../boot
+	if test -f boot/libcamlrun.a; then :; else \
+	  ln -s ../byterun/libcamlrun.a boot/libcamlrun.a; fi
+	if test -d stdlib/caml; then :; else \
+	  ln -s ../byterun stdlib/caml; fi
+
+# Build the core system: the minimum needed to make depend and bootstrap
+core:
+	$(MAKE) coldstart
+	$(MAKE) coreall
+
+# Recompile the core system using the bootstrap compiler
+coreall:
+	$(MAKE) ocamlc
+	$(MAKE) ocamllex ocamlyacc ocamltools library
+
+# Save the current bootstrap compiler
+MAXSAVED=boot/Saved/Saved.prev/Saved.prev/Saved.prev/Saved.prev/Saved.prev
+backup:
+	if test -d boot/Saved; then : ; else mkdir boot/Saved; fi
+	if test -d $(MAXSAVED); then rm -r $(MAXSAVED); else : ; fi
+	mv boot/Saved boot/Saved.prev
+	mkdir boot/Saved
+	mv boot/Saved.prev boot/Saved/Saved.prev
+	cp boot/ocamlrun$(EXE) boot/Saved
+	mv boot/ocamlc boot/ocamllex boot/ocamlyacc$(EXE) boot/ocamldep \
+	   boot/Saved
+	cd boot; cp $(LIBFILES) Saved
+
+# Promote the newly compiled system to the rank of cross compiler
+# (Runs on the old runtime, produces code for the new runtime)
+promote-cross:
+	cp ocamlc boot/ocamlc
+	cp lex/ocamllex boot/ocamllex
+	cp yacc/ocamlyacc$(EXE) boot/ocamlyacc$(EXE)
+	cp tools/ocamldep boot/ocamldep
+	cd stdlib; cp $(LIBFILES) ../boot
+
+# Promote the newly compiled system to the rank of bootstrap compiler
+# (Runs on the new runtime, produces code for the new runtime)
+promote: promote-cross
+	cp byterun/ocamlrun$(EXE) boot/ocamlrun$(EXE)
+
+# Restore the saved bootstrap compiler if a problem arises
+restore:
+	mv boot/Saved/* boot
+	rmdir boot/Saved
+	mv boot/Saved.prev boot/Saved
+
+# Check if fixpoint reached
+compare:
+	@if cmp boot/ocamlc ocamlc && cmp boot/ocamllex lex/ocamllex \
+	    && cmp boot/ocamldep tools/ocamldep; \
+	then echo "Fixpoint reached, bootstrap succeeded."; \
+	else echo "Fixpoint not reached, try one more bootstrapping cycle."; \
+	fi
+
+# Remove old bootstrap compilers
+cleanboot:
+	rm -rf boot/Saved/Saved.prev/*
+
+# Compile the native-code compiler
+opt-core:
+	$(MAKE) runtimeopt
+	$(MAKE) ocamlopt
+	$(MAKE) libraryopt
+
+opt:
+	$(MAKE) runtimeopt
+	$(MAKE) ocamlopt
+	$(MAKE) libraryopt
+	$(MAKE) otherlibrariesopt ocamltoolsopt $(OCAMLBUILDNATIVE)
+
+# Native-code versions of the tools
+opt.opt:
+	$(MAKE) checkstack
+	$(MAKE) runtime
+	$(MAKE) core
+	$(MAKE) ocaml
+	$(MAKE) opt-core
+	$(MAKE) ocamlc.opt
+	$(MAKE) otherlibraries $(WITH_DEBUGGER) $(WITH_OCAMLDOC) \
+	        $(OCAMLBUILDBYTE)
+	$(MAKE) ocamlopt.opt
+	$(MAKE) otherlibrariesopt
+	$(MAKE) ocamllex.opt ocamltoolsopt ocamltoolsopt.opt $(OCAMLDOC_OPT) \
+	        $(OCAMLBUILDNATIVE)
+
+base.opt:
+	$(MAKE) checkstack
+	$(MAKE) runtime
+	$(MAKE) core
+	$(MAKE) ocaml
+	$(MAKE) opt-core
+	$(MAKE) ocamlc.opt
+	$(MAKE) otherlibraries $(OCAMLBUILDBYTE) $(WITH_DEBUGGER) \
+	  $(WITH_OCAMLDOC)
+	$(MAKE) ocamlopt.opt
+	$(MAKE) otherlibrariesopt
+
+# Installation
+
+COMPLIBDIR=$(LIBDIR)/compiler-libs
+
+INSTALL_BINDIR=$(DESTDIR)$(BINDIR)
+INSTALL_LIBDIR=$(DESTDIR)$(LIBDIR)
+INSTALL_COMPLIBDIR=$(DESTDIR)$(COMPLIBDIR)
+INSTALL_STUBLIBDIR=$(DESTDIR)$(STUBLIBDIR)
+INSTALL_MANDIR=$(DESTDIR)$(MANDIR)
+
+install:
+	if test -d $(INSTALL_BINDIR); then : ; \
+	  else $(MKDIR) $(INSTALL_BINDIR); fi
+	if test -d $(INSTALL_LIBDIR); then : ; \
+	  else $(MKDIR) $(INSTALL_LIBDIR); fi
+	if test -d $(INSTALL_STUBLIBDIR); then : ; \
+	  else $(MKDIR) $(INSTALL_STUBLIBDIR); fi
+	if test -d $(INSTALL_COMPLIBDIR); then : ; \
+	  else $(MKDIR) $(INSTALL_COMPLIBDIR); fi
+	if test -d $(INSTALL_MANDIR)/man$(MANEXT); then : ; \
+	  else $(MKDIR) $(INSTALL_MANDIR)/man$(MANEXT); fi
+	cp VERSION $(INSTALL_LIBDIR)/
+	cd $(INSTALL_LIBDIR); rm -f dllbigarray.so dllnums.so dllthreads.so \
+	  dllunix.so dllgraphics.so dllstr.so
+	cd byterun; $(MAKE) install
+	cp ocamlc $(INSTALL_BINDIR)/ocamlc$(EXE)
+	cp ocaml $(INSTALL_BINDIR)/ocaml$(EXE)
+	cd stdlib; $(MAKE) install
+	cp lex/ocamllex $(INSTALL_BINDIR)/ocamllex$(EXE)
+	cp yacc/ocamlyacc$(EXE) $(INSTALL_BINDIR)/ocamlyacc$(EXE)
+	cp utils/*.cmi parsing/*.cmi typing/*.cmi bytecomp/*.cmi driver/*.cmi \
+	   toplevel/*.cmi $(INSTALL_COMPLIBDIR)
+	cp compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma \
+	   compilerlibs/ocamltoplevel.cma $(BYTESTART) $(TOPLEVELSTART) \
+	   $(INSTALL_COMPLIBDIR)
+	cp expunge $(INSTALL_LIBDIR)/expunge$(EXE)
+	cp toplevel/topdirs.cmi $(INSTALL_LIBDIR)
+	cd tools; $(MAKE) install
+	-cd man; $(MAKE) install
+	for i in $(OTHERLIBRARIES); do \
+	  (cd otherlibs/$$i; $(MAKE) install) || exit $$?; \
+	done
+	if test -n "$(WITH_OCAMLDOC)"; then (cd ocamldoc; $(MAKE) install); else :; fi
+	if test -n "$(WITH_DEBUGGER)"; then (cd debugger; $(MAKE) install); \
+	   else :; fi
+	if test -n "$(WITH_OCAMLBUILD)"; then (cd ocamlbuild; $(MAKE) install); \
+	   else :; fi
+	cp config/Makefile $(INSTALL_LIBDIR)/Makefile.config
+	if test -f ocamlopt; then $(MAKE) installopt; else :; fi
+
+# Installation of the native-code compiler
+installopt:
+	cd asmrun; $(MAKE) install
+	cp ocamlopt $(INSTALL_BINDIR)/ocamlopt$(EXE)
+	cd stdlib; $(MAKE) installopt
+	cp asmcomp/*.cmi $(INSTALL_COMPLIBDIR)
+	cp compilerlibs/ocamloptcomp.cma $(OPTSTART) $(INSTALL_COMPLIBDIR)
+	if test -n "$(WITH_OCAMLDOC)"; then (cd ocamldoc; $(MAKE) installopt); \
+		else :; fi
+	if test -n "$(WITH_OCAMLBUILD)"; then (cd ocamlbuild; $(MAKE) installopt); \
+	   else :; fi
+	for i in $(OTHERLIBRARIES); \
+	  do (cd otherlibs/$$i; $(MAKE) installopt) || exit $$?; done
+	if test -f ocamlopt.opt ; then $(MAKE) installoptopt; fi
+	cd tools; $(MAKE) installopt
+
+installoptopt:
+	cp ocamlc.opt $(INSTALL_BINDIR)/ocamlc.opt$(EXE)
+	cp ocamlopt.opt $(INSTALL_BINDIR)/ocamlopt.opt$(EXE)
+	cp lex/ocamllex.opt $(INSTALL_BINDIR)/ocamllex.opt$(EXE)
+	cp compilerlibs/ocamlcommon.cmxa compilerlibs/ocamlcommon.a \
+	   compilerlibs/ocamlbytecomp.cmxa compilerlibs/ocamlbytecomp.a \
+	   compilerlibs/ocamloptcomp.cmxa compilerlibs/ocamloptcomp.a \
+	   $(BYTESTART:.cmo=.cmx) $(BYTESTART:.cmo=.o) \
+	   $(OPTSTART:.cmo=.cmx) $(OPTSTART:.cmo=.o) \
+	   $(INSTALL_COMPLIBDIR)
+	cd $(INSTALL_COMPLIBDIR) && $(RANLIB) ocamlcommon.a ocamlbytecomp.a \
+	   ocamloptcomp.a
+
+# Run all tests
+
+tests: opt.opt
+	cd testsuite; $(MAKE) clean && $(MAKE) all
+
+# The clean target
+
+clean:: partialclean
+
+# Shared parts of the system
+
+compilerlibs/ocamlcommon.cma: $(COMMON)
+	$(CAMLC) -a -linkall -o $@ $(COMMON)
+partialclean::
+	rm -f compilerlibs/ocamlcommon.cma
+
+# The bytecode compiler
+
+compilerlibs/ocamlbytecomp.cma: $(BYTECOMP)
+	$(CAMLC) -a -o $@ $(BYTECOMP)
+partialclean::
+	rm -f compilerlibs/ocamlbytecomp.cma
+
+ocamlc: compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma $(BYTESTART)
+	$(CAMLC) $(LINKFLAGS) -compat-32 -o ocamlc \
+	   compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma $(BYTESTART)
+
+# The native-code compiler
+
+compilerlibs/ocamloptcomp.cma: $(ASMCOMP)
+	$(CAMLC) -a -o $@ $(ASMCOMP)
+partialclean::
+	rm -f compilerlibs/ocamloptcomp.cma
+
+ocamlopt: compilerlibs/ocamlcommon.cma compilerlibs/ocamloptcomp.cma $(OPTSTART)
+	$(CAMLC) $(LINKFLAGS) -o ocamlopt \
+	  compilerlibs/ocamlcommon.cma compilerlibs/ocamloptcomp.cma $(OPTSTART)
+
+partialclean::
+	rm -f ocamlopt
+
+# The toplevel
+
+compilerlibs/ocamltoplevel.cma: $(TOPLEVEL)
+	$(CAMLC) -a -o $@ $(TOPLEVEL)
+partialclean::
+	rm -f compilerlibs/ocamltoplevel.cma
+
+ocaml: compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma \
+       compilerlibs/ocamltoplevel.cma $(TOPLEVELSTART) expunge
+	$(CAMLC) $(LINKFLAGS) -linkall -o ocaml.tmp \
+	  compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma \
+	  compilerlibs/ocamltoplevel.cma $(TOPLEVELSTART)
+	- $(CAMLRUN) ./expunge ocaml.tmp ocaml $(PERVASIVES)
+	rm -f ocaml.tmp
+
+partialclean::
+	rm -f ocaml
+
+# The native toplevel
+
+ocamlnat: ocamlopt otherlibs/dynlink/dynlink.cmxa $(NATTOPOBJS:.cmo=.cmx)
+	$(CAMLOPT) $(LINKFLAGS) otherlibs/dynlink/dynlink.cmxa -o ocamlnat \
+	           $(NATTOPOBJS:.cmo=.cmx) -linkall
+
+toplevel/opttoploop.cmx: otherlibs/dynlink/dynlink.cmxa
+
+otherlibs/dynlink/dynlink.cmxa: otherlibs/dynlink/natdynlink.ml
+	cd otherlibs/dynlink && $(MAKE) allopt
+
+# The configuration file
+
+utils/config.ml: utils/config.mlp config/Makefile
+	@rm -f utils/config.ml
+	sed -e 's|%%LIBDIR%%|$(LIBDIR)|' \
+	    -e 's|%%BYTERUN%%|$(BINDIR)/ocamlrun|' \
+	    -e 's|%%CCOMPTYPE%%|cc|' \
+	    -e 's|%%BYTECC%%|$(BYTECC) $(BYTECCCOMPOPTS) $(SHAREDCCCOMPOPTS)|' \
+	    -e 's|%%NATIVECC%%|$(NATIVECC) $(NATIVECCCOMPOPTS)|' \
+	    -e 's|%%PACKLD%%|$(PACKLD)|' \
+	    -e 's|%%BYTECCLIBS%%|$(BYTECCLIBS)|' \
+	    -e 's|%%NATIVECCLIBS%%|$(NATIVECCLIBS)|' \
+	    -e 's|%%RANLIBCMD%%|$(RANLIBCMD)|' \
+	    -e 's|%%ARCMD%%|$(ARCMD)|' \
+	    -e 's|%%CC_PROFILE%%|$(CC_PROFILE)|' \
+	    -e 's|%%ARCH%%|$(ARCH)|' \
+	    -e 's|%%MODEL%%|$(MODEL)|' \
+	    -e 's|%%SYSTEM%%|$(SYSTEM)|' \
+	    -e 's|%%EXT_OBJ%%|.o|' \
+	    -e 's|%%EXT_ASM%%|.s|' \
+	    -e 's|%%EXT_LIB%%|.a|' \
+	    -e 's|%%EXT_DLL%%|.so|' \
+	    -e 's|%%SYSTHREAD_SUPPORT%%|$(SYSTHREAD_SUPPORT)|' \
+	    -e 's|%%ASM%%|$(ASM)|' \
+	    -e 's|%%ASM_CFI_SUPPORTED%%|$(ASM_CFI_SUPPORTED)|' \
+	    -e 's|%%WITH_FRAME_POINTERS%%|$(WITH_FRAME_POINTERS)|' \
+	    -e 's|%%MKDLL%%|$(MKDLL)|' \
+	    -e 's|%%MKEXE%%|$(MKEXE)|' \
+	    -e 's|%%MKMAINDLL%%|$(MKMAINDLL)|' \
+	    -e 's|%%HOST%%|$(HOST)|' \
+	    -e 's|%%TARGET%%|$(TARGET)|' \
+	    utils/config.mlp > utils/config.ml
+
+partialclean::
+	rm -f utils/config.ml
+
+beforedepend:: utils/config.ml
+
+# The parser
+
+parsing/parser.mli parsing/parser.ml: parsing/parser.mly
+	$(CAMLYACC) $(YACCFLAGS) parsing/parser.mly
+
+partialclean::
+	rm -f parsing/parser.mli parsing/parser.ml parsing/parser.output
+
+beforedepend:: parsing/parser.mli parsing/parser.ml
+
+# The lexer
+
+parsing/lexer.ml: parsing/lexer.mll
+	$(CAMLLEX) parsing/lexer.mll
+
+partialclean::
+	rm -f parsing/lexer.ml
+
+beforedepend:: parsing/lexer.ml
+
+# Shared parts of the system compiled with the native-code compiler
+
+compilerlibs/ocamlcommon.cmxa: $(COMMON:.cmo=.cmx)
+	$(CAMLOPT) -a -linkall -o $@ $(COMMON:.cmo=.cmx)
+partialclean::
+	rm -f compilerlibs/ocamlcommon.cmxa compilerlibs/ocamlcommon.a
+
+# The bytecode compiler compiled with the native-code compiler
+
+compilerlibs/ocamlbytecomp.cmxa: $(BYTECOMP:.cmo=.cmx)
+	$(CAMLOPT) -a -o $@ $(BYTECOMP:.cmo=.cmx)
+partialclean::
+	rm -f compilerlibs/ocamlbytecomp.cmxa compilerlibs/ocamlbytecomp.a
+
+ocamlc.opt: compilerlibs/ocamlcommon.cmxa compilerlibs/ocamlbytecomp.cmxa \
+            $(BYTESTART:.cmo=.cmx)
+	$(CAMLOPT) $(LINKFLAGS) -ccopt "$(BYTECCLINKOPTS)" -o ocamlc.opt \
+	  compilerlibs/ocamlcommon.cmxa compilerlibs/ocamlbytecomp.cmxa \
+	  $(BYTESTART:.cmo=.cmx) -cclib "$(BYTECCLIBS)"
+
+partialclean::
+	rm -f ocamlc.opt
+
+# The native-code compiler compiled with itself
+
+compilerlibs/ocamloptcomp.cmxa: $(ASMCOMP:.cmo=.cmx)
+	$(CAMLOPT) -a -o $@ $(ASMCOMP:.cmo=.cmx)
+partialclean::
+	rm -f compilerlibs/ocamloptcomp.cmxa compilerlibs/ocamloptcomp.a
+
+ocamlopt.opt: compilerlibs/ocamlcommon.cmxa compilerlibs/ocamloptcomp.cmxa \
+              $(OPTSTART:.cmo=.cmx)
+	$(CAMLOPT) $(LINKFLAGS) -o ocamlopt.opt \
+	   compilerlibs/ocamlcommon.cmxa compilerlibs/ocamloptcomp.cmxa \
+	   $(OPTSTART:.cmo=.cmx)
+
+partialclean::
+	rm -f ocamlopt.opt
+
+$(COMMON:.cmo=.cmx) $(BYTECOMP:.cmo=.cmx) $(ASMCOMP:.cmo=.cmx): ocamlopt
+
+# The numeric opcodes
+
+bytecomp/opcodes.ml: byterun/instruct.h
+	sed -n -e '/^enum/p' -e 's/,//g' -e '/^  /p' byterun/instruct.h | \
+	awk -f tools/make-opcodes > bytecomp/opcodes.ml
+
+partialclean::
+	rm -f bytecomp/opcodes.ml
+
+beforedepend:: bytecomp/opcodes.ml
+
+# The predefined exceptions and primitives
+
+byterun/primitives:
+	cd byterun; $(MAKE) primitives
+
+bytecomp/runtimedef.ml: byterun/primitives byterun/fail.h
+	(echo 'let builtin_exceptions = [|'; \
+	 sed -n -e 's|.*/\* \("[A-Za-z_]*"\) \*/$$|  \1;|p' byterun/fail.h | \
+	 sed -e '$$s/;$$//'; \
+	 echo '|]'; \
+	 echo 'let builtin_primitives = [|'; \
+	 sed -e 's/.*/  "&";/' -e '$$s/;$$//' byterun/primitives; \
+	 echo '|]') > bytecomp/runtimedef.ml
+
+partialclean::
+	rm -f bytecomp/runtimedef.ml
+
+beforedepend:: bytecomp/runtimedef.ml
+
+# Choose the right machine-dependent files
+
+asmcomp/arch.ml: asmcomp/$(ARCH)/arch.ml
+	ln -s $(ARCH)/arch.ml asmcomp/arch.ml
+
+partialclean::
+	rm -f asmcomp/arch.ml
+
+beforedepend:: asmcomp/arch.ml
+
+asmcomp/proc.ml: asmcomp/$(ARCH)/proc.ml
+	ln -s $(ARCH)/proc.ml asmcomp/proc.ml
+
+partialclean::
+	rm -f asmcomp/proc.ml
+
+beforedepend:: asmcomp/proc.ml
+
+asmcomp/selection.ml: asmcomp/$(ARCH)/selection.ml
+	ln -s $(ARCH)/selection.ml asmcomp/selection.ml
+
+partialclean::
+	rm -f asmcomp/selection.ml
+
+beforedepend:: asmcomp/selection.ml
+
+asmcomp/CSE.ml: asmcomp/$(ARCH)/CSE.ml
+	ln -s $(ARCH)/CSE.ml asmcomp/CSE.ml
+
+partialclean::
+	rm -f asmcomp/CSE.ml
+
+beforedepend:: asmcomp/CSE.ml
+
+asmcomp/reload.ml: asmcomp/$(ARCH)/reload.ml
+	ln -s $(ARCH)/reload.ml asmcomp/reload.ml
+
+partialclean::
+	rm -f asmcomp/reload.ml
+
+beforedepend:: asmcomp/reload.ml
+
+asmcomp/scheduling.ml: asmcomp/$(ARCH)/scheduling.ml
+	ln -s $(ARCH)/scheduling.ml asmcomp/scheduling.ml
+
+partialclean::
+	rm -f asmcomp/scheduling.ml
+
+beforedepend:: asmcomp/scheduling.ml
+
+# Preprocess the code emitters
+
+asmcomp/emit.ml: asmcomp/$(ARCH)/emit.mlp tools/cvt_emit
+	$(CAMLRUN) tools/cvt_emit < asmcomp/$(ARCH)/emit.mlp > asmcomp/emit.ml \
+	|| { rm -f asmcomp/emit.ml; exit 2; }
+
+partialclean::
+	rm -f asmcomp/emit.ml
+
+beforedepend:: asmcomp/emit.ml
+
+tools/cvt_emit: tools/cvt_emit.mll
+	cd tools; \
+	$(MAKE) CAMLC="../$(CAMLRUN) ../boot/ocamlc -I ../stdlib" cvt_emit
+
+# The "expunge" utility
+
+expunge: compilerlibs/ocamlcommon.cma compilerlibs/ocamlbytecomp.cma \
+         toplevel/expunge.cmo
+	$(CAMLC) $(LINKFLAGS) -o expunge compilerlibs/ocamlcommon.cma \
+	         compilerlibs/ocamlbytecomp.cma toplevel/expunge.cmo
+
+partialclean::
+	rm -f expunge
+
+# The runtime system for the bytecode compiler
+
+runtime:
+	cd byterun; $(MAKE) all
+	if test -f stdlib/libcamlrun.a; then :; else \
+	  ln -s ../byterun/libcamlrun.a stdlib/libcamlrun.a; fi
+
+clean::
+	cd byterun; $(MAKE) clean
+	rm -f stdlib/libcamlrun.a
+	rm -f stdlib/caml
+
+alldepend::
+	cd byterun; $(MAKE) depend
+
+# The runtime system for the native-code compiler
+
+runtimeopt: makeruntimeopt
+	cp asmrun/libasmrun.a stdlib/libasmrun.a
+
+makeruntimeopt:
+	cd asmrun; $(MAKE) all
+
+clean::
+	cd asmrun; $(MAKE) clean
+	rm -f stdlib/libasmrun.a
+
+alldepend::
+	cd asmrun; $(MAKE) depend
+
+# The library
+
+library: ocamlc
+	cd stdlib; $(MAKE) all
+
+library-cross:
+	cd stdlib; $(MAKE) RUNTIME=../byterun/ocamlrun all
+
+libraryopt:
+	cd stdlib; $(MAKE) allopt
+
+partialclean::
+	cd stdlib; $(MAKE) clean
+
+alldepend::
+	cd stdlib; $(MAKE) depend
+
+# The lexer and parser generators
+
+ocamllex: ocamlyacc ocamlc
+	cd lex; $(MAKE) all
+
+ocamllex.opt: ocamlopt
+	cd lex; $(MAKE) allopt
+
+partialclean::
+	cd lex; $(MAKE) clean
+
+alldepend::
+	cd lex; $(MAKE) depend
+
+ocamlyacc:
+	cd yacc; $(MAKE) all
+
+clean::
+	cd yacc; $(MAKE) clean
+
+# Tools
+
+ocamltools: ocamlc ocamlyacc ocamllex asmcomp/cmx_format.cmi \
+            asmcomp/printclambda.cmo
+	cd tools; $(MAKE) all
+
+ocamltoolsopt: ocamlopt
+	cd tools; $(MAKE) opt
+
+ocamltoolsopt.opt: ocamlc.opt ocamlyacc ocamllex asmcomp/cmx_format.cmi \
+                   asmcomp/printclambda.cmx
+	cd tools; $(MAKE) opt.opt
+
+partialclean::
+	cd tools; $(MAKE) clean
+
+alldepend::
+	cd tools; $(MAKE) depend
+
+# OCamldoc
+
+ocamldoc: ocamlc ocamlyacc ocamllex otherlibraries
+	cd ocamldoc && $(MAKE) all
+
+ocamldoc.opt: ocamlc.opt ocamlyacc ocamllex
+	cd ocamldoc && $(MAKE) opt.opt
+
+# Documentation
+
+html_doc: ocamldoc
+	make -C ocamldoc html_doc
+	@echo "documentation is in ./ocamldoc/stdlib_html/"
+
+partialclean::
+	cd ocamldoc && $(MAKE) clean
+
+alldepend::
+	cd ocamldoc && $(MAKE) depend
+
+# The extra libraries
+
+otherlibraries: ocamltools
+	for i in $(OTHERLIBRARIES); do \
+	  (cd otherlibs/$$i; $(MAKE) RUNTIME=$(RUNTIME) all) || exit $$?; \
+	done
+
+otherlibrariesopt:
+	for i in $(OTHERLIBRARIES); do \
+	  (cd otherlibs/$$i; $(MAKE) allopt) || exit $$?; \
+	done
+
+partialclean::
+	for i in $(OTHERLIBRARIES); do \
+	  (cd otherlibs/$$i && $(MAKE) partialclean); \
+	done
+
+clean::
+	for i in $(OTHERLIBRARIES); do (cd otherlibs/$$i && $(MAKE) clean); done
+
+alldepend::
+	for i in $(OTHERLIBRARIES); do (cd otherlibs/$$i; $(MAKE) depend); done
+
+# The replay debugger
+
+ocamldebugger: ocamlc ocamlyacc ocamllex otherlibraries
+	cd debugger; $(MAKE) all
+
+partialclean::
+	cd debugger; $(MAKE) clean
+
+alldepend::
+	cd debugger; $(MAKE) depend
+
+# Ocamlbuild
+
+ocamlbuild.byte: ocamlc otherlibraries
+	cd ocamlbuild && $(MAKE) all
+
+ocamlbuild.native: ocamlopt otherlibrariesopt
+	cd ocamlbuild && $(MAKE) allopt
+
+partialclean::
+	cd ocamlbuild && $(MAKE) clean
+
+alldepend::
+	cd ocamlbuild && $(MAKE) depend
+
+# Check that the stack limit is reasonable.
+
+checkstack:
+	@if $(BYTECC) $(BYTECCCOMPOPTS) $(BYTECCLINKOPTS) \
+	              -o tools/checkstack tools/checkstack.c; \
+	  then tools/checkstack; \
+	  else :; \
+	fi
+	@rm -f tools/checkstack
+
+# Make clean in the test suite
+
+clean::
+	cd testsuite; $(MAKE) clean
+
+# Make MacOS X package
+
+package-macosx:
+	sudo rm -rf package-macosx/root
+	$(MAKE) PREFIX="`pwd`"/package-macosx/root install
+	tools/make-package-macosx
+	sudo rm -rf package-macosx/root
+
+clean::
+	rm -rf package-macosx/*.pkg package-macosx/*.dmg
+
+# Default rules
+
+.SUFFIXES: .ml .mli .cmo .cmi .cmx
+
+.ml.cmo:
+	$(CAMLC) $(COMPFLAGS) -c $<
+
+.mli.cmi:
+	$(CAMLC) $(COMPFLAGS) -c $<
+
+.ml.cmx:
+	$(CAMLOPT) $(COMPFLAGS) -c $<
+
+partialclean::
+	for d in utils parsing typing bytecomp asmcomp driver toplevel tools; \
+	  do rm -f $$d/*.cm[ioxt] $$d/*.cmti $$d/*.annot $$d/*.[so] $$d/*~; done
+	rm -f *~
+
+depend: beforedepend
+	(for d in utils parsing typing bytecomp asmcomp driver toplevel; \
+	 do $(CAMLDEP) $(DEPFLAGS) $$d/*.mli $$d/*.ml; \
+	 done) > .depend
+
+alldepend:: depend
+
+distclean:
+	$(MAKE) clean
+	rm -f boot/ocamlrun boot/ocamlrun.exe boot/camlheader boot/ocamlyacc \
+	      boot/*.cm* boot/libcamlrun.a
+	rm -f config/Makefile config/m.h config/s.h
+	rm -f tools/*.bak
+	rm -f ocaml ocamlc
+	rm -f testsuite/_log
+
+.PHONY: all backup bootstrap checkstack clean
+.PHONY: partialclean beforedepend alldepend cleanboot coldstart
+.PHONY: compare core coreall
+.PHONY: coreboot defaultentry depend distclean install installopt
+.PHONY: library library-cross libraryopt
+.PHONY: ocamlbuild.byte ocamlbuild.native ocamldebugger ocamldoc
+.PHONY: ocamldoc.opt ocamllex ocamllex.opt ocamltools ocamltoolsopt
+.PHONY: ocamltoolsopt.opt ocamlyacc opt-core opt opt.opt otherlibraries
+.PHONY: otherlibrariesopt package-macosx promote promote-cross
+.PHONY: restore runtime runtimeopt makeruntimeopt world world.opt
+
+include .depend
diff -urN ocaml-4.02.1-clean/asmcomp/arm/arch.ml ocaml-4.02.1-ios/asmcomp/arm/arch.ml
--- ocaml-4.02.1-clean/asmcomp/arm/arch.ml	2014-08-21 14:06:19.000000000 +0400
+++ ocaml-4.02.1-ios/asmcomp/arm/arch.ml	2014-10-29 12:47:20.000000000 +0300
@@ -246,6 +246,36 @@
    and rotated right by 0 ... 30 bits.
    In Thumb/Thumb-2 mode we utilize 26 ... 30. *)
 
+let count_leading_zeros v =
+  if v = 0l then 32
+  else
+    let rec loop shift v res =
+      let tmp = Int32.shift_right_logical v shift in
+      let (v,res) =
+        if tmp = 0l then (v,(res lor shift)) else  (tmp,res)
+      in
+      let shift = shift lsr 1 in
+      if shift = 0 then res else loop shift v res
+      in
+      loop 16 v 0
+
+let is_immediate (v:Int32.t) =
+  if Int32.logand v 0xffffff00l = 0l then true
+  else
+    let vs = if Int32.logand v 0xffl = 0l then Int32.shift_right_logical v 8 else v in
+    let imm = Int32.logand vs 0xffl in
+    let u = Int32.logor imm (Int32.shift_left imm 16) in
+    if vs = u then true
+    else
+      if vs = (Int32.logor u (Int32.shift_left u 8)) then true
+      else
+        let rotAmt = count_leading_zeros v in
+        if rotAmt >= 24 then false
+        else
+          let r =  Int32.logor (Int32.shift_right_logical 0xff000000l rotAmt) (Int32.shift_left 0xff000000l ((32 - rotAmt) land 31)) in
+          if Int32.logand r v = v then true
+          else false
+
 let is_immediate n =
   let n = ref n in
   let s = ref 0 in
diff -urN ocaml-4.02.1-clean/asmcomp/arm/emit.mlp ocaml-4.02.1-ios/asmcomp/arm/emit.mlp
--- ocaml-4.02.1-clean/asmcomp/arm/emit.mlp	2014-04-26 14:40:22.000000000 +0400
+++ ocaml-4.02.1-ios/asmcomp/arm/emit.mlp	2014-10-29 12:47:20.000000000 +0300
@@ -29,25 +29,20 @@
 (* Output a label *)
 
 let emit_label lbl =
-  emit_string ".L"; emit_int lbl
+  emit_string "L"; emit_int lbl
 
 let emit_data_label lbl =
-  emit_string ".Ld"; emit_int lbl
+  emit_string "Ld"; emit_int lbl
 
 (* Symbols *)
 
 let emit_symbol s =
-  Emitaux.emit_symbol '$' s
+  emit_string "_"; Emitaux.emit_symbol '$' s
 
 let emit_call s =
-  if !Clflags.dlcode || !pic_code
-  then `bl	{emit_symbol s}(PLT)`
-  else `bl	{emit_symbol s}`
-
-let emit_jump s =
-  if !Clflags.dlcode || !pic_code
-  then `b	{emit_symbol s}(PLT)`
-  else `b	{emit_symbol s}`
+  `bl	{emit_symbol s}`
+
+let emit_jump s = `b	{emit_symbol s}`
 
 (* Output a pseudo-register *)
 
@@ -321,7 +316,7 @@
   end;
   if !symbol_literals <> [] then begin
     let offset = if !thumb then 4 else 8 in
-    let suffix = if !pic_code then "(GOT)" else "" in
+    let suffix = "" in (* if !pic_code then "(GOT)" else "" in *)
     `	.align	2\n`;
     List.iter
       (fun (l, lbl) ->
@@ -351,7 +346,7 @@
               else phys_reg 8 (*r12*) in
     `	ldr	{emit_reg tmp}, {emit_label lbl_got}\n`;
     `	ldr	{emit_reg dst}, {emit_label lbl_sym}\n`;
-    `{emit_label lbl_pic}:	add	{emit_reg tmp}, pc, {emit_reg tmp}\n`;
+    `{emit_label lbl_pic}:	add	{emit_reg tmp}, pc\n`;
     `	ldr	{emit_reg dst}, [{emit_reg tmp}, {emit_reg dst}] @ {emit_symbol s}\n`;
     4
   end else if !arch > ARMv6 && not !Clflags.dlcode && !fastcode_flag then begin
@@ -373,20 +368,21 @@
     | Lop(Imove | Ispill | Ireload) ->
         let src = i.arg.(0) and dst = i.res.(0) in
         if src.loc = dst.loc then 0 else begin
-          begin match (src, dst) with
-            {loc = Reg _; typ = Float}, {loc = Reg _} ->
-              `	fcpyd	{emit_reg dst}, {emit_reg src}\n`
-          | {loc = Reg _}, {loc = Reg _} ->
-              `	mov	{emit_reg dst}, {emit_reg src}\n`
-          | {loc = Reg _; typ = Float}, _ ->
-              `	fstd	{emit_reg src}, {emit_stack dst}\n`
-          | {loc = Reg _}, _ ->
-              `	str	{emit_reg src}, {emit_stack dst}\n`
-          | {typ = Float}, _ ->
-              `	fldd	{emit_reg dst}, {emit_stack src}\n`
-          | _ ->
-              `	ldr	{emit_reg dst}, {emit_stack src}\n`
-          end; 1
+           begin match (src, dst) with
+             {loc = Reg _; typ = Float}, {loc = Reg _} ->
+              `	vmov	{emit_reg dst}, {emit_reg src}\n`
+           | {loc = Reg _}, {loc = Reg _} ->
+               `	mov	{emit_reg dst}, {emit_reg src}\n`
+           | {loc = Reg _; typ = Float}, _ ->
+              `	vstr.f64	{emit_reg src}, {emit_stack dst}\n`
+           | {loc = Reg _}, _ ->
+               `	str	{emit_reg src}, {emit_stack dst}\n`
+           | {typ = Float}, _ ->
+              `	vldr.f64	{emit_reg dst}, {emit_stack src}\n`
+           | _ ->
+               `	ldr	{emit_reg dst}, {emit_stack src}\n`
+           end; 1
+
         end
     | Lop(Iconst_int n | Iconst_blockheader n) ->
         emit_intconst i.res.(0) (Nativeint.to_int32 n)
@@ -410,7 +406,7 @@
         1
     | Lop(Iconst_float f) ->
         let encode imm =
-          let sg = Int64.to_int (Int64.shift_right_logical imm 63) in
+          (* let sg = Int64.to_int (Int64.shift_right_logical imm 63) in *)
           let ex = Int64.to_int (Int64.shift_right_logical imm 52) in
           let ex = (ex land 0x7ff) - 1023 in
           let mn = Int64.logand imm 0xfffffffffffffL in
@@ -421,16 +417,18 @@
             let mn = Int64.to_int (Int64.shift_right_logical mn 48) in
             if mn land 0x0f <> mn then
               None
-            else
+            else Some f
+						(*
               let ex = ((ex + 3) land 0x07) lxor 0x04 in
               Some((sg lsl 7) lor (ex lsl 4) lor mn)
+						*)
           end in
         begin match encode (Int64.bits_of_float f) with
           None ->
             let lbl = float_literal f in
-            `	fldd	{emit_reg i.res.(0)}, {emit_label lbl}\n`
+            ` vldr.f64	{emit_reg i.res.(0)}, {emit_label lbl} @ {emit_string (string_of_float f)}\n`
         | Some imm8 ->
-            `	fconstd	{emit_reg i.res.(0)}, #{emit_int imm8}\n`
+            ` vmov.f64	{emit_reg i.res.(0)}, #{emit_string (string_of_float imm8)}\n`
         end; 1
     | Lop(Iconst_symbol s) ->
         emit_load_symbol_addr i.res.(0) s
@@ -476,7 +474,7 @@
         ninstr
     | Lop(Iload(Single, addr)) when !fpu >= VFPv2 ->
         `	flds	s14, {emit_addressing addr i.arg 0}\n`;
-        `	fcvtds	{emit_reg i.res.(0)}, s14\n`; 2
+        `	vcvt.f64.f32	{emit_reg i.res.(0)}, s14\n`; 2
     | Lop(Iload((Double | Double_u), addr)) when !fpu = Soft ->
         (* Use LDM or LDRD if possible *)
         begin match i.res.(0), i.res.(1), addr with
@@ -505,12 +503,12 @@
           | Sixteen_unsigned -> "ldrh"
           | Sixteen_signed -> "ldrsh"
           | Double
-          | Double_u -> "fldd"
+          | Double_u -> "vldr.f64"
           | _ (* 32-bit quantities *) -> "ldr" in
         `	{emit_string instr}	{emit_reg r}, {emit_addressing addr i.arg 0}\n`; 1
     | Lop(Istore(Single, addr, _)) when !fpu >= VFPv2 ->
-        `	fcvtsd	s14, {emit_reg i.arg.(0)}\n`;
-        `	fsts	s14, {emit_addressing addr i.arg 1}\n`; 2
+        `	vcvt.f32.f64	s14, {emit_reg i.arg.(0)}\n`;
+        `	vstr.f32	s14, {emit_addressing addr i.arg 1}\n`; 2
     | Lop(Istore((Double | Double_u), addr, _)) when !fpu = Soft ->
         (* Use STM or STRD if possible *)
         begin match i.arg.(0), i.arg.(1), addr with
@@ -534,7 +532,7 @@
           | Sixteen_unsigned
           | Sixteen_signed -> "strh"
           | Double
-          | Double_u -> "fstd"
+          | Double_u -> "vstr.f64"
           | _ (* 32-bit quantities *) -> "str" in
         `	{emit_string instr}	{emit_reg r}, {emit_addressing addr i.arg 1}\n`; 1
     | Lop(Ialloc n) ->
@@ -600,7 +598,7 @@
         `	smmla	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}\n`; 1
     | Lop(Iintop op) ->
         let instr = name_for_int_operation op in
-        `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`; 1
+        `	{emit_string instr}     {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`; 1
     | Lop(Iintop_imm(op, n)) ->
         let instr = name_for_int_operation op in
         `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, #{emit_int n}\n`; 1
@@ -612,33 +610,33 @@
         `	{emit_string instr}	{emit_reg i.res.(1)}, {emit_reg i.arg.(1)}, #0x80000000\n`; 1
     | Lop(Iabsf | Inegf | Ispecific Isqrtf as op) ->
         let instr = (match op with
-                       Iabsf            -> "fabsd"
-                     | Inegf            -> "fnegd"
-                     | Ispecific Isqrtf -> "fsqrtd"
+                       Iabsf            -> "vabs.f64"
+                     | Inegf            -> "vneg.f64"
+                     | Ispecific Isqrtf -> "vsqrt.f64"
                      | _                -> assert false) in
         `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}\n`; 1
     | Lop(Ifloatofint) ->
         `	fmsr	s14, {emit_reg i.arg.(0)}\n`;
-        `	fsitod	{emit_reg i.res.(0)}, s14\n`; 2
+        `	vcvt.f64.s32	{emit_reg i.res.(0)}, s14\n`; 2
     | Lop(Iintoffloat) ->
-        `	ftosizd	s14, {emit_reg i.arg.(0)}\n`;
+        `	vcvt.s32.f64	s14, {emit_reg i.arg.(0)}\n`;
         `	fmrs	{emit_reg i.res.(0)}, s14\n`; 2
     | Lop(Iaddf | Isubf | Imulf | Idivf | Ispecific Inegmulf as op) ->
         let instr = (match op with
-                       Iaddf              -> "faddd"
-                     | Isubf              -> "fsubd"
-                     | Imulf              -> "fmuld"
-                     | Idivf              -> "fdivd"
-                     | Ispecific Inegmulf -> "fnmuld"
+                       Iaddf              -> "vadd.f64"
+                     | Isubf              -> "vsub.f64"
+                     | Imulf              -> "vmul.f64"
+                     | Idivf              -> "vdiv.f64"
+                     | Ispecific Inegmulf -> "vnmul.f64"
                      | _                  -> assert false) in
         `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
         1
     | Lop(Ispecific(Imuladdf | Inegmuladdf | Imulsubf | Inegmulsubf as op)) ->
         let instr = (match op with
-                       Imuladdf    -> "fmacd"
-                     | Inegmuladdf -> "fnmacd"
-                     | Imulsubf    -> "fmscd"
-                     | Inegmulsubf -> "fnmscd"
+                       Imuladdf    -> "vmla.f64"
+                     | Inegmuladdf -> "vmls.f64"
+                     | Imulsubf    -> "vnmls.f64"
+                     | Inegmulsubf -> "vnmla.f64"
                      | _ -> assert false) in
         `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}\n`;
         1
@@ -709,7 +707,7 @@
                         | (Cgt, true)  -> "le"
                         | (Cge, false) -> "ge"
                         | (Cge, true)  -> "lt") in
-            `	fcmpd	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
+            `	vcmp.f64	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
             `	fmstat\n`;
             `	b{emit_string comp}	{emit_label lbl}\n`; 3
         | Ioddtest ->
@@ -739,8 +737,11 @@
           (* The Thumb-2 TBH instruction supports only forward branches,
              so we need to generate appropriate trampolines for all labels
              that appear before this switch instruction (PR#5623) *)
+
+	  let lbl = new_label () in
           let tramtbl = Array.copy jumptbl in
           `	tbh	[pc, {emit_reg i.arg.(0)}, lsl #1]\n`;
+	  `{emit_label lbl}:`;
           for j = 0 to Array.length tramtbl - 1 do
             let rec label i =
               match i.desc with
@@ -748,7 +749,7 @@
               | Llabel lbl when lbl = tramtbl.(j) -> lbl
               | _ -> label i.next in
             tramtbl.(j) <- label i.next;
-            `	.short	({emit_label tramtbl.(j)}-.)/2+{emit_int j}\n`
+            `	.short	({emit_label tramtbl.(j)}-{emit_label lbl})/2\n`
           done;
           (* Generate the necessary trampolines *)
           for j = 0 to Array.length tramtbl - 1 do
@@ -838,13 +839,13 @@
   call_gc_sites := [];
   bound_error_sites := [];
   `	.text\n`;
-  `	.align	2\n`;
   `	.globl	{emit_symbol fundecl.fun_name}\n`;
+  `	.align	2\n`;
   if !arch > ARMv6 && !thumb then
     `	.thumb\n`
   else
     `	.arm\n`;
-  `	.type	{emit_symbol fundecl.fun_name}, %function\n`;
+  `  .thumb_func {emit_symbol fundecl.fun_name}\n`;
   `{emit_symbol fundecl.fun_name}:\n`;
   emit_debug_info fundecl.fun_dbg;
   cfi_startproc();
@@ -860,10 +861,8 @@
   emit_literals();
   List.iter emit_call_gc !call_gc_sites;
   List.iter emit_call_bound_error !bound_error_sites;
-  cfi_endproc();
-  `	.type	{emit_symbol fundecl.fun_name}, %function\n`;
-  `	.size	{emit_symbol fundecl.fun_name}, .-{emit_symbol fundecl.fun_name}\n`
-
+  cfi_endproc()
+  
 (* Emission of data *)
 
 let emit_item = function
@@ -889,11 +888,12 @@
 (* Beginning / end of an assembly file *)
 
 let begin_assembly() =
-  reset_debug_info();
-  `	.syntax	unified\n`;
-  begin match !arch with
-  | ARMv4   -> `	.arch	armv4t\n`
-  | ARMv5   -> `	.arch	armv5t\n`
+   reset_debug_info();
+   `	.syntax	unified\n`;
+	(*
+   begin match !arch with
+   | ARMv4   -> `	.arch	armv4t\n`
+   | ARMv5   -> `	.arch	armv5t\n`
   | ARMv5TE -> `	.arch	armv5te\n`
   | ARMv6   -> `	.arch	armv6\n`
   | ARMv6T2 -> `	.arch	armv6t2\n`
@@ -903,50 +903,48 @@
     Soft      -> `	.fpu	softvfp\n`
   | VFPv2     -> `	.fpu	vfpv2\n`
   | VFPv3_D16 -> `	.fpu	vfpv3-d16\n`
+  | VFPv3_D16 -> `	.fpu	vfpv3-d16\n`
   | VFPv3     -> `	.fpu	vfpv3\n`
-  end;
-  `trap_ptr	.req	r8\n`;
-  `alloc_ptr	.req	r10\n`;
-  `alloc_limit	.req	r11\n`;
+   end;
+	*)
+   `trap_ptr	.req	r8\n`;
+   `alloc_ptr	.req	r10\n`;
+   `alloc_limit	.req	r11\n`;
   let lbl_begin = Compilenv.make_symbol (Some "data_begin") in
   `	.data\n`;
   `	.globl	{emit_symbol lbl_begin}\n`;
   `{emit_symbol lbl_begin}:\n`;
-  let lbl_begin = Compilenv.make_symbol (Some "code_begin") in
-  `	.text\n`;
-  `	.globl	{emit_symbol lbl_begin}\n`;
-  `{emit_symbol lbl_begin}:\n`
+     let lbl_begin = Compilenv.make_symbol (Some "code_begin") in
+   `	.text\n`;
+   `	.globl	{emit_symbol lbl_begin}\n`;
+  `{emit_symbol lbl_begin}:\n`;
+	` nop\n`
+
+ let end_assembly () =
+   let lbl_end = Compilenv.make_symbol (Some "code_end") in
+   `	.text\n`;
+   `	.globl	{emit_symbol lbl_end}\n`;
+   `{emit_symbol lbl_end}:\n`;
+	` nop\n`;
+   let lbl_end = Compilenv.make_symbol (Some "data_end") in
+   `	.data\n`;
+   `	.globl	{emit_symbol lbl_end}\n`;
 
-let end_assembly () =
-  let lbl_end = Compilenv.make_symbol (Some "code_end") in
-  `	.text\n`;
-  `	.globl	{emit_symbol lbl_end}\n`;
-  `{emit_symbol lbl_end}:\n`;
-  let lbl_end = Compilenv.make_symbol (Some "data_end") in
-  `	.data\n`;
-  `	.globl	{emit_symbol lbl_end}\n`;
   `{emit_symbol lbl_end}:\n`;
   `	.long	0\n`;
   let lbl = Compilenv.make_symbol (Some "frametable") in
   `	.globl	{emit_symbol lbl}\n`;
-  `{emit_symbol lbl}:\n`;
-  emit_frames
-    { efa_label = (fun lbl ->
-                       `	.type	{emit_label lbl}, %function\n`;
-                       `	.word	{emit_label lbl}\n`);
-      efa_16 = (fun n -> `	.short	{emit_int n}\n`);
-      efa_32 = (fun n -> `	.long	{emit_int32 n}\n`);
+   `{emit_symbol lbl}:\n`;
+   emit_frames
+     { efa_label = (fun lbl ->
+         (*              `	.type	{emit_label lbl}, %function\n`; *)
+                        `	.word	{emit_label lbl}\n`);
+       efa_16 = (fun n -> `	.short	{emit_int n}\n`);
+       efa_32 = (fun n -> `	.long	{emit_int32 n}\n`);
       efa_word = (fun n -> `	.word	{emit_int n}\n`);
       efa_align = (fun n -> `	.align	{emit_int(Misc.log2 n)}\n`);
-      efa_label_rel = (fun lbl ofs ->
-                           `	.word	{emit_label lbl} - . + {emit_int32 ofs}\n`);
-      efa_def_label = (fun lbl -> `{emit_label lbl}:\n`);
-      efa_string = (fun s -> emit_string_directive "	.asciz	" s) };
-  `	.type	{emit_symbol lbl}, %object\n`;
-  `	.size	{emit_symbol lbl}, .-{emit_symbol lbl}\n`;
-  begin match Config.system with
-    "linux_eabihf" | "linux_eabi" ->
-      (* Mark stack as non-executable *)
-      `	.section	.note.GNU-stack,\"\",%progbits\n`
-  | _ -> ()
-  end
+       efa_label_rel = (fun lbl ofs ->
+                            `	.word	{emit_label lbl} - . + {emit_int32 ofs}\n`);
+       efa_def_label = (fun lbl -> `{emit_label lbl}:\n`);
+      efa_string = (fun s -> emit_string_directive "	.asciz	" s) }
+
diff -urN ocaml-4.02.1-clean/asmcomp/arm/selection.ml ocaml-4.02.1-ios/asmcomp/arm/selection.ml
--- ocaml-4.02.1-clean/asmcomp/arm/selection.ml	2014-10-09 13:33:36.000000000 +0400
+++ ocaml-4.02.1-ios/asmcomp/arm/selection.ml	2014-10-29 12:47:20.000000000 +0300
@@ -192,10 +192,10 @@
       (Iintop Imulh, args)
   (* Turn integer division/modulus into runtime ABI calls *)
   | (Cdivi, args) ->
-      (Iextcall("__aeabi_idiv", false), args)
+      (Iextcall("__divsi3", false), args)
   | (Cmodi, args) ->
       (* See above for fix up of return register *)
-      (Iextcall("__aeabi_idivmod", false), args)
+      (Iextcall("__modsi3", false), args)
   (* Recognize 16-bit bswap instruction (ARMv6T2 because we need movt) *)
   | (Cextcall("caml_bswap16_direct", _, _, _), args) when !arch >= ARMv6T2 ->
       (Ispecific(Ibswap 16), args)
diff -urN ocaml-4.02.1-clean/asmcomp/arm/selection.ml.orig ocaml-4.02.1-ios/asmcomp/arm/selection.ml.orig
--- ocaml-4.02.1-clean/asmcomp/arm/selection.ml.orig	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.02.1-ios/asmcomp/arm/selection.ml.orig	2014-10-09 13:33:36.000000000 +0400
@@ -0,0 +1,293 @@
+(***********************************************************************)
+(*                                                                     *)
+(*                                OCaml                                *)
+(*                                                                     *)
+(*                  Benedikt Meurer, University of Siegen              *)
+(*                                                                     *)
+(*    Copyright 1998 Institut National de Recherche en Informatique    *)
+(*    et en Automatique. Copyright 2012 Benedikt Meurer. All rights    *)
+(*    reserved.  This file is distributed  under the terms of the Q    *)
+(*    Public License version 1.0.                                      *)
+(*                                                                     *)
+(***********************************************************************)
+
+(* Instruction selection for the ARM processor *)
+
+open Arch
+open Proc
+open Cmm
+open Mach
+
+let is_offset chunk n =
+  match chunk with
+  (* VFPv{2,3} load/store have -1020 to 1020 *)
+    Single | Double | Double_u
+    when !fpu >= VFPv2 ->
+      n >= -1020 && n <= 1020
+  (* ARM load/store byte/word have -4095 to 4095 *)
+  | Byte_unsigned | Byte_signed
+  | Thirtytwo_unsigned | Thirtytwo_signed
+  | Word | Single
+    when not !thumb ->
+      n >= -4095 && n <= 4095
+  (* Thumb-2 load/store have -255 to 4095 *)
+  | _ when !arch > ARMv6 && !thumb ->
+      n >= -255 && n <= 4095
+  (* Everything else has -255 to 255 *)
+  | _ ->
+      n >= -255 && n <= 255
+
+let select_shiftop = function
+    Clsl -> Ishiftlogicalleft
+  | Clsr -> Ishiftlogicalright
+  | Casr -> Ishiftarithmeticright
+  | __-> assert false
+
+(* Special constraints on operand and result registers *)
+
+exception Use_default
+
+let r1 = phys_reg 1
+let r6 = phys_reg 6
+let r7 = phys_reg 7
+let r12 = phys_reg 8
+
+let pseudoregs_for_operation op arg res =
+  match op with
+  (* For mul rd,rm,rs and mla rd,rm,rs,ra (pre-ARMv6) the registers rm
+     and rd must be different. We deal with this by pretending that rm
+     is also a result of the mul / mla operation. *)
+    Iintop Imul | Ispecific Imuladd when !arch < ARMv6 ->
+      (arg, [| res.(0); arg.(0) |])
+  (* For smull rdlo,rdhi,rn,rm (pre-ARMv6) the registers rdlo, rdhi and rn
+     must be different.  Also, rdlo (whose contents we discard) is always
+     forced to be r12 in proc.ml, which means that neither rdhi and rn can
+     be r12.  To keep things simple, we force both of those two to specific
+     hard regs: rdhi in r6 and rn in r7. *)
+  | Iintop Imulh when !arch < ARMv6 ->
+      ([| r7; arg.(1) |], [| r6 |])
+  (* Soft-float Iabsf and Inegf: arg.(0) and res.(0) must be the same *)
+  | Iabsf | Inegf when !fpu = Soft ->
+      ([|res.(0); arg.(1)|], res)
+  (* VFPv{2,3} Imuladdf...Inegmulsubf: arg.(0) and res.(0) must be the same *)
+  | Ispecific(Imuladdf | Inegmuladdf | Imulsubf | Inegmulsubf) ->
+      let arg' = Array.copy arg in
+      arg'.(0) <- res.(0);
+      (arg', res)
+  (* We use __aeabi_idivmod for Cmodi only, and hence we care only
+     for the remainder in r1, so fix up the destination register. *)
+  | Iextcall("__aeabi_idivmod", false) ->
+      (arg, [|r1|])
+  (* Other instructions are regular *)
+  | _ -> raise Use_default
+
+(* Instruction selection *)
+class selector = object(self)
+
+inherit Selectgen.selector_generic as super
+
+method! regs_for tyv =
+  Reg.createv (if !fpu = Soft then begin
+                 (* Expand floats into pairs of integer registers *)
+                 let rec expand = function
+                   [] -> []
+                 | Float :: tyl -> Int :: Int :: expand tyl
+                 | ty :: tyl -> ty :: expand tyl in
+                 Array.of_list (expand (Array.to_list tyv))
+               end else begin
+                 tyv
+               end)
+
+method is_immediate n =
+  is_immediate (Int32.of_int n)
+
+method! is_simple_expr = function
+  (* inlined floating-point ops are simple if their arguments are *)
+  | Cop(Cextcall("sqrt", _, _, _), args) when !fpu >= VFPv2 ->
+      List.for_all self#is_simple_expr args
+  (* inlined byte-swap ops are simple if their arguments are *)
+  | Cop(Cextcall("caml_bswap16_direct", _, _, _), args) when !arch >= ARMv6T2 ->
+      List.for_all self#is_simple_expr args
+  | Cop(Cextcall("caml_int32_direct_bswap", _,_,_), args) when !arch >= ARMv6 ->
+      List.for_all self#is_simple_expr args
+  | e -> super#is_simple_expr e
+
+method select_addressing chunk = function
+  | Cop(Cadda, [arg; Cconst_int n])
+    when is_offset chunk n ->
+      (Iindexed n, arg)
+  | Cop(Cadda, [arg1; Cop(Caddi, [arg2; Cconst_int n])])
+    when is_offset chunk n ->
+      (Iindexed n, Cop(Cadda, [arg1; arg2]))
+  | arg ->
+      (Iindexed 0, arg)
+
+method select_shift_arith op arithop arithrevop args =
+  match args with
+    [arg1; Cop(Clsl | Clsr | Casr as op, [arg2; Cconst_int n])]
+    when n > 0 && n < 32 ->
+      (Ispecific(Ishiftarith(arithop, select_shiftop op, n)), [arg1; arg2])
+  | [Cop(Clsl | Clsr | Casr as op, [arg1; Cconst_int n]); arg2]
+    when n > 0 && n < 32 ->
+      (Ispecific(Ishiftarith(arithrevop, select_shiftop op, n)), [arg2; arg1])
+  | args ->
+      begin match super#select_operation op args with
+      (* Recognize multiply high and add *)
+        (Iintop Iadd, [Cop(Cmulhi, args); arg3])
+      | (Iintop Iadd, [arg3; Cop(Cmulhi, args)]) as op_args
+        when !arch >= ARMv6 ->
+          begin match self#select_operation Cmulhi args with
+            (Iintop Imulh, [arg1; arg2]) ->
+              (Ispecific Imulhadd, [arg1; arg2; arg3])
+          | _ -> op_args
+          end
+      (* Recognize multiply and add *)
+      | (Iintop Iadd, [Cop(Cmuli, args); arg3])
+      | (Iintop Iadd, [arg3; Cop(Cmuli, args)]) as op_args ->
+          begin match self#select_operation Cmuli args with
+            (Iintop Imul, [arg1; arg2]) ->
+              (Ispecific Imuladd, [arg1; arg2; arg3])
+          | _ -> op_args
+          end
+      (* Recognize multiply and subtract *)
+      | (Iintop Isub, [arg3; Cop(Cmuli, args)]) as op_args
+        when !arch > ARMv6 ->
+          begin match self#select_operation Cmuli args with
+            (Iintop Imul, [arg1; arg2]) ->
+              (Ispecific Imulsub, [arg1; arg2; arg3])
+          | _ -> op_args
+          end
+      | op_args -> op_args
+      end
+
+method! select_operation op args =
+  match (op, args) with
+  (* Recognize special shift arithmetic *)
+    ((Cadda | Caddi), [arg; Cconst_int n])
+    when n < 0 && self#is_immediate (-n) ->
+      (Iintop_imm(Isub, -n), [arg])
+  | ((Cadda | Caddi as op), args) ->
+      self#select_shift_arith op Ishiftadd Ishiftadd args
+  | ((Csuba | Csubi), [arg; Cconst_int n])
+    when n < 0 && self#is_immediate (-n) ->
+      (Iintop_imm(Iadd, -n), [arg])
+  | ((Csuba | Csubi), [Cconst_int n; arg])
+    when self#is_immediate n ->
+      (Ispecific(Irevsubimm n), [arg])
+  | ((Csuba | Csubi as op), args) ->
+      self#select_shift_arith op Ishiftsub Ishiftsubrev args
+  | (Cand as op, args) ->
+      self#select_shift_arith op Ishiftand Ishiftand args
+  | (Cor as op, args) ->
+      self#select_shift_arith op Ishiftor Ishiftor args
+  | (Cxor as op, args) ->
+      self#select_shift_arith op Ishiftxor Ishiftxor args
+  | (Ccheckbound _, [Cop(Clsl | Clsr | Casr as op, [arg1; Cconst_int n]); arg2])
+    when n > 0 && n < 32 ->
+      (Ispecific(Ishiftcheckbound(select_shiftop op, n)), [arg1; arg2])
+  (* ARM does not support immediate operands for multiplication *)
+  | (Cmuli, args) ->
+      (Iintop Imul, args)
+  | (Cmulhi, args) ->
+      (Iintop Imulh, args)
+  (* Turn integer division/modulus into runtime ABI calls *)
+  | (Cdivi, args) ->
+      (Iextcall("__aeabi_idiv", false), args)
+  | (Cmodi, args) ->
+      (* See above for fix up of return register *)
+      (Iextcall("__aeabi_idivmod", false), args)
+  (* Recognize 16-bit bswap instruction (ARMv6T2 because we need movt) *)
+  | (Cextcall("caml_bswap16_direct", _, _, _), args) when !arch >= ARMv6T2 ->
+      (Ispecific(Ibswap 16), args)
+  (* Recognize 32-bit bswap instructions (ARMv6 and above) *)
+  | (Cextcall("caml_int32_direct_bswap", _, _, _), args) when !arch >= ARMv6 ->
+      (Ispecific(Ibswap 32), args)
+  (* Turn floating-point operations into runtime ABI calls for softfp *)
+  | (op, args) when !fpu = Soft -> self#select_operation_softfp op args
+  (* Select operations for VFPv{2,3} *)
+  | (op, args) -> self#select_operation_vfpv3 op args
+
+method private select_operation_softfp op args =
+  match (op, args) with
+  (* Turn floating-point operations into runtime ABI calls *)
+  | (Caddf, args) -> (Iextcall("__aeabi_dadd", false), args)
+  | (Csubf, args) -> (Iextcall("__aeabi_dsub", false), args)
+  | (Cmulf, args) -> (Iextcall("__aeabi_dmul", false), args)
+  | (Cdivf, args) -> (Iextcall("__aeabi_ddiv", false), args)
+  | (Cfloatofint, args) -> (Iextcall("__aeabi_i2d", false), args)
+  | (Cintoffloat, args) -> (Iextcall("__aeabi_d2iz", false), args)
+  | (Ccmpf comp, args) ->
+      let func = (match comp with
+                    Cne    (* there's no __aeabi_dcmpne *)
+                  | Ceq -> "__aeabi_dcmpeq"
+                  | Clt -> "__aeabi_dcmplt"
+                  | Cle -> "__aeabi_dcmple"
+                  | Cgt -> "__aeabi_dcmpgt"
+                  | Cge -> "__aeabi_dcmpge") in
+      let comp = (match comp with
+                    Cne -> Ceq (* eq 0 => false *)
+                  | _   -> Cne (* ne 0 => true *)) in
+      (Iintop_imm(Icomp(Iunsigned comp), 0),
+       [Cop(Cextcall(func, typ_int, false, Debuginfo.none), args)])
+  (* Add coercions around loads and stores of 32-bit floats *)
+  | (Cload Single, args) ->
+      (Iextcall("__aeabi_f2d", false), [Cop(Cload Word, args)])
+  | (Cstore Single, [arg1; arg2]) ->
+      let arg2' =
+        Cop(Cextcall("__aeabi_d2f", typ_int, false, Debuginfo.none),
+            [arg2]) in
+      self#select_operation (Cstore Word) [arg1; arg2']
+  (* Other operations are regular *)
+  | (op, args) -> super#select_operation op args
+
+method private select_operation_vfpv3 op args =
+  match (op, args) with
+  (* Recognize floating-point negate and multiply *)
+    (Cnegf, [Cop(Cmulf, args)]) ->
+      (Ispecific Inegmulf, args)
+  (* Recognize floating-point multiply and add *)
+  | (Caddf, [arg; Cop(Cmulf, args)])
+  | (Caddf, [Cop(Cmulf, args); arg]) ->
+      (Ispecific Imuladdf, arg :: args)
+  (* Recognize floating-point negate, multiply and subtract *)
+  | (Csubf, [Cop(Cnegf, [arg]); Cop(Cmulf, args)])
+  | (Csubf, [Cop(Cnegf, [Cop(Cmulf, args)]); arg]) ->
+      (Ispecific Inegmulsubf, arg :: args)
+  (* Recognize floating-point negate, multiply and add *)
+  | (Csubf, [arg; Cop(Cmulf, args)]) ->
+      (Ispecific Inegmuladdf, arg :: args)
+  (* Recognize multiply and subtract *)
+  | (Csubf, [Cop(Cmulf, args); arg]) ->
+      (Ispecific Imulsubf, arg :: args)
+  (* Recognize floating-point square root *)
+  | (Cextcall("sqrt", _, false, _), args) ->
+      (Ispecific Isqrtf, args)
+  (* Other operations are regular *)
+  | (op, args) -> super#select_operation op args
+
+method! select_condition = function
+  (* Turn floating-point comparisons into runtime ABI calls *)
+    Cop(Ccmpf _ as op, args) when !fpu = Soft ->
+      begin match self#select_operation_softfp op args with
+        (Iintop_imm(Icomp(Iunsigned Ceq), 0), [arg]) -> (Ifalsetest, arg)
+      | (Iintop_imm(Icomp(Iunsigned Cne), 0), [arg]) -> (Itruetest, arg)
+      | _ -> assert false
+      end
+  | expr ->
+      super#select_condition expr
+
+(* Deal with some register constraints *)
+
+method! insert_op_debug op dbg rs rd =
+  try
+    let (rsrc, rdst) = pseudoregs_for_operation op rs rd in
+    self#insert_moves rs rsrc;
+    self#insert_debug (Iop op) dbg rsrc rdst;
+    self#insert_moves rdst rd;
+    rd
+  with Use_default ->
+    super#insert_op_debug op dbg rs rd
+
+end
+
+let fundecl f = (new selector)#emit_fundecl f
diff -urN ocaml-4.02.1-clean/asmcomp/cmmgen.ml ocaml-4.02.1-ios/asmcomp/cmmgen.ml
--- ocaml-4.02.1-clean/asmcomp/cmmgen.ml	2014-08-18 22:26:49.000000000 +0400
+++ ocaml-4.02.1-ios/asmcomp/cmmgen.ml	2014-10-29 12:47:20.000000000 +0300
@@ -211,14 +211,14 @@
 
 (* Unsigned comparison between native integers. *)
 
-let ucompare x y = Nativeint.(compare (add x min_int) (add y min_int))
+let ucompare x y = Int32.(compare (add x min_int) (add y min_int))
 
 (* Unsigned division and modulus at type nativeint.
    Algorithm: Hacker's Delight section 9.3 *)
 
-let udivmod n d = Nativeint.(
-  if d < 0n then
-    if ucompare n d < 0 then (0n, n) else (1n, sub n d)
+let udivmod n d = Int32.(
+  if d < 0l then
+    if ucompare n d < 0 then (0l, n) else (1l, sub n d)
   else begin
     let q = shift_left (div (shift_right_logical n 1) d) 1 in
     let r = sub n (mul q d) in
@@ -228,8 +228,9 @@
 (* Compute division parameters.
    Algorithm: Hacker's Delight chapter 10, fig 10-1. *)
 
-let divimm_parameters d = Nativeint.(
-  assert (d > 0n);
+let divimm_parameters d = Int32.(
+  assert (d > 0l);
+	let size = 32 in
   let twopsm1 = min_int in (* 2^31 for 32-bit archs, 2^63 for 64-bit archs *)
   let nc = sub (pred twopsm1) (snd (udivmod twopsm1 d)) in
   let rec loop p (q1, r1) (q2, r2) =
@@ -241,7 +242,7 @@
     let (q2, r2) =
       if ucompare r2 d >= 0 then (succ q2, sub r2 d) else (q2, r2) in
     let delta = sub d r2 in
-    if ucompare q1 delta < 0 || (q1 = delta && r1 = 0n)
+    if ucompare q1 delta < 0 || (q1 = delta && r1 = 0l)
     then loop p (q1, r1) (q2, r2)
     else (succ q2, p - size)
   in loop (size - 1) (udivmod twopsm1 nc) (udivmod twopsm1 d))
@@ -306,6 +307,7 @@
   | (Cconst_int n1, Cconst_int n2) ->
       Cconst_int (n1 / n2)
   | (c1, Cconst_int n) when n <> min_int ->
+		let nativeintSize = 32 in
       let l = Misc.log2 n in
       if n = 1 lsl l then
         (* Algorithm:
@@ -316,13 +318,13 @@
         *)
         Cop(Casr, [bind "dividend" c1 (fun c1 ->
                      let t = asr_int c1 (Cconst_int (l - 1)) in
-                     let t = lsr_int t (Cconst_int (Nativeint.size - l)) in
+                     let t = lsr_int t (Cconst_int (nativeintSize - l)) in
                      add_int c1 t);
                    Cconst_int l])
       else if n < 0 then
         sub_int (Cconst_int 0) (div_int c1 (Cconst_int (-n)) dbg)
       else begin
-        let (m, p) = divimm_parameters (Nativeint.of_int n) in
+        let (m, p) = divimm_parameters (Int32.of_int n) in
         (* Algorithm:
               t = multiply-high-signed(c1, m)
               if m < 0, t = t + c1
@@ -330,10 +332,10 @@
               res = t + sign-bit(c1)
         *)
         bind "dividend" c1 (fun c1 ->
-          let t = Cop(Cmulhi, [c1; Cconst_natint m]) in
-          let t = if m < 0n then Cop(Caddi, [t; c1]) else t in
+          let t = Cop(Cmulhi, [c1; Cconst_natint (Nativeint.of_int32 m)]) in
+          let t = if m < 0l then Cop(Caddi, [t; c1]) else t in
           let t = if p > 0 then Cop(Casr, [t; Cconst_int p]) else t in
-          add_int t (lsr_int c1 (Cconst_int (Nativeint.size - 1))))
+          add_int t (lsr_int c1 (Cconst_int (32 - 1))))
       end
   | (c1, c2) when !Clflags.fast ->
       Cop(Cdivi, [c1; c2])
@@ -356,6 +358,7 @@
   | (Cconst_int n1, Cconst_int n2) ->
       Cconst_int (n1 mod n2)
   | (c1, (Cconst_int n as c2)) when n <> min_int ->
+			let nativeintSize = 32 in
       let l = Misc.log2 n in
       if n = 1 lsl l then
         (* Algorithm:
@@ -367,7 +370,7 @@
          *)
         bind "dividend" c1 (fun c1 ->
           let t = asr_int c1 (Cconst_int (l - 1)) in
-          let t = lsr_int t (Cconst_int (Nativeint.size - l)) in
+          let t = lsr_int t (Cconst_int (nativeintSize - l)) in
           let t = add_int c1 t in
           let t = Cop(Cand, [t; Cconst_int (-n)]) in
           sub_int c1 t)
diff -urN ocaml-4.02.1-clean/asmcomp/liveness.ml ocaml-4.02.1-ios/asmcomp/liveness.ml
--- ocaml-4.02.1-clean/asmcomp/liveness.ml	2014-05-16 18:52:07.000000000 +0400
+++ ocaml-4.02.1-ios/asmcomp/liveness.ml	2014-10-29 12:47:20.000000000 +0300
@@ -54,7 +54,8 @@
         let across =
           match op with
           | Icall_ind | Icall_imm _ | Iextcall _
-          | Iintop Icheckbound | Iintop_imm(Icheckbound, _) ->
+          | Iintop Icheckbound | Iintop_imm(Icheckbound, _)
+					| Ispecific(Arch.Ishiftcheckbound _) ->
               (* The function call may raise an exception, branching to the
                  nearest enclosing try ... with. Similarly for bounds checks.
                  Hence, everything that must be live at the beginning of
diff -urN ocaml-4.02.1-clean/asmcomp/spill.ml ocaml-4.02.1-ios/asmcomp/spill.ml
--- ocaml-4.02.1-clean/asmcomp/spill.ml	2014-08-18 22:26:49.000000000 +0400
+++ ocaml-4.02.1-ios/asmcomp/spill.ml	2014-10-29 12:47:20.000000000 +0300
@@ -296,7 +296,8 @@
       let before =
         match i.desc with
           Iop Icall_ind | Iop(Icall_imm _) | Iop(Iextcall _)
-        | Iop(Iintop Icheckbound) | Iop(Iintop_imm(Icheckbound, _)) ->
+        | Iop(Iintop Icheckbound) | Iop(Iintop_imm(Icheckbound, _))
+        | Iop(Ispecific(Arch.Ishiftcheckbound _)) ->
             Reg.Set.union before1 !spill_at_raise
         | _ ->
             before1 in
diff -urN ocaml-4.02.1-clean/asmrun/arm.S ocaml-4.02.1-ios/asmrun/arm.S
--- ocaml-4.02.1-clean/asmrun/arm.S	2014-08-21 14:06:19.000000000 +0400
+++ ocaml-4.02.1-ios/asmrun/arm.S	2014-10-29 12:47:20.000000000 +0300
@@ -15,46 +15,14 @@
 /* Asm part of the runtime system, ARM processor */
 /* Must be preprocessed by cpp */
 
-        .syntax unified
+#define CONCAT(a,b) a##b
+#define G(x) CONCAT(_,x)
+#define LBL(x) CONCAT(L,x)
+
+
+	.syntax unified
         .text
-#if defined(SYS_linux_eabihf) && defined(MODEL_armv6)
-        .arch   armv6
-        .fpu    vfpv2
-        .arm
-
-    /* Compatibility macros */
-        .macro  cbz reg, lbl
-        cmp     \reg, #0
-        beq     \lbl
-        .endm
-#elif defined(SYS_linux_eabihf)
-        .arch   armv7-a
-        .fpu    vfpv3-d16
         .thumb
-#elif defined(SYS_linux_eabi)
-        .arch   armv4t
-        .arm
-
-    /* Compatibility macros */
-        .macro  blx reg
-        mov     lr, pc
-        bx      \reg
-        .endm
-        .macro  cbz reg, lbl
-        cmp     \reg, #0
-        beq     \lbl
-        .endm
-#elif defined(SYS_freebsd)
-        .arch   armv6
-        .arm
-
-    /* Compatibility macros */
-        .macro  cbz reg, lbl
-        cmp     \reg, #0
-        beq     \lbl
-        .endm
-#endif
-
 trap_ptr        .req    r8
 alloc_ptr       .req    r10
 alloc_limit     .req    r11
@@ -71,391 +39,353 @@
 #define CFI_ADJUST(n)
 #endif
 
-/* Support for profiling with gprof */
-
-#if defined(PROFILING) && (defined(SYS_linux_eabihf) || defined(SYS_linux_eabi))
-#define PROFILE \
-        push    {lr}; CFI_ADJUST(4); \
-        bl      __gnu_mcount_nc; CFI_ADJUST(-4)
-#else
-#define PROFILE
-#endif
-
 /* Allocation functions and GC interface */
 
-        .globl  caml_system__code_begin
-caml_system__code_begin:
-
-        .align  2
-        .globl  caml_call_gc
-caml_call_gc:
-        CFI_STARTPROC
-        PROFILE
-    /* Record return address */
-        ldr     r12, =caml_last_return_address
-        str     lr, [r12]
-.Lcaml_call_gc:
-    /* Record lowest stack address */
-        ldr     r12, =caml_bottom_of_stack
-        str     sp, [r12]
-#if defined(SYS_linux_eabihf)
-    /* Save caller floating-point registers on the stack */
-        vpush   {d0-d7}; CFI_ADJUST(64)
-#endif
-    /* Save integer registers and return address on the stack */
-        push    {r0-r7,r12,lr}; CFI_ADJUST(40)
-    /* Store pointer to saved integer registers in caml_gc_regs */
-        ldr     r12, =caml_gc_regs
-        str     sp, [r12]
-    /* Save current allocation pointer for debugging purposes */
-        ldr     alloc_limit, =caml_young_ptr
-        str     alloc_ptr, [alloc_limit]
-    /* Save trap pointer in case an exception is raised during GC */
-        ldr     r12, =caml_exception_pointer
-        str     trap_ptr, [r12]
-    /* Call the garbage collector */
-        bl      caml_garbage_collection
-    /* Restore integer registers and return address from the stack */
-        pop     {r0-r7,r12,lr}; CFI_ADJUST(-40)
-#if defined(SYS_linux_eabihf)
-    /* Restore floating-point registers from the stack */
-        vpop    {d0-d7}; CFI_ADJUST(-64)
-#endif
-    /* Reload new allocation pointer and limit */
-    /* alloc_limit still points to caml_young_ptr */
-        ldr     r12, =caml_young_limit
-        ldr     alloc_ptr, [alloc_limit]
-        ldr     alloc_limit, [r12]
-    /* Return to caller */
-        bx      lr
-        CFI_ENDPROC
-        .type   caml_call_gc, %function
-        .size   caml_call_gc, .-caml_call_gc
+        .globl  G(caml_system__code_begin)
+G(caml_system__code_begin):
 
-        .align  2
-        .globl  caml_alloc1
-caml_alloc1:
-        CFI_STARTPROC
-        PROFILE
-.Lcaml_alloc1:
-        sub     alloc_ptr, alloc_ptr, 8
-        cmp     alloc_ptr, alloc_limit
-        bcc     1f
-        bx      lr
-1:  /* Record return address */
-        ldr     r7, =caml_last_return_address
-        str     lr, [r7]
-    /* Call GC (preserves r7) */
-        bl      .Lcaml_call_gc
-    /* Restore return address */
-        ldr     lr, [r7]
-    /* Try again */
-        b       .Lcaml_alloc1
-        CFI_ENDPROC
-        .type   caml_alloc1, %function
-        .size   caml_alloc1, .-caml_alloc1
-
-        .align  2
-        .globl  caml_alloc2
-caml_alloc2:
-        CFI_STARTPROC
-        PROFILE
-.Lcaml_alloc2:
-        sub     alloc_ptr, alloc_ptr, 12
-        cmp     alloc_ptr, alloc_limit
-        bcc     1f
-        bx      lr
-1:  /* Record return address */
-        ldr     r7, =caml_last_return_address
-        str     lr, [r7]
-    /* Call GC (preserves r7) */
-        bl      .Lcaml_call_gc
-    /* Restore return address */
-        ldr     lr, [r7]
-    /* Try again */
-        b       .Lcaml_alloc2
-        CFI_ENDPROC
-        .type   caml_alloc2, %function
-        .size   caml_alloc2, .-caml_alloc2
-
-        .align  2
-        .globl  caml_alloc3
-        .type caml_alloc3, %function
-caml_alloc3:
-        CFI_STARTPROC
-        PROFILE
-.Lcaml_alloc3:
-        sub     alloc_ptr, alloc_ptr, 16
-        cmp     alloc_ptr, alloc_limit
-        bcc     1f
-        bx      lr
-1:  /* Record return address */
-        ldr     r7, =caml_last_return_address
-        str     lr, [r7]
-    /* Call GC (preserves r7) */
-        bl      .Lcaml_call_gc
-    /* Restore return address */
-        ldr     lr, [r7]
-    /* Try again */
-        b       .Lcaml_alloc3
-        CFI_ENDPROC
-        .type   caml_alloc3, %function
-        .size   caml_alloc3, .-caml_alloc3
-
-        .align  2
-        .globl  caml_allocN
-caml_allocN:
-        CFI_STARTPROC
-        PROFILE
-.Lcaml_allocN:
-        sub     alloc_ptr, alloc_ptr, r7
-        cmp     alloc_ptr, alloc_limit
-        bcc     1f
-        bx      lr
-1:  /* Record return address */
-        ldr     r12, =caml_last_return_address
-        str     lr, [r12]
-    /* Call GC (preserves r7) */
-        bl      .Lcaml_call_gc
-    /* Restore return address */
-        ldr     r12, =caml_last_return_address
-        ldr     lr, [r12]
-    /* Try again */
-        b       .Lcaml_allocN
-        CFI_ENDPROC
-        .type   caml_allocN, %function
-        .size   caml_allocN, .-caml_allocN
-
-/* Call a C function from OCaml */
-/* Function to call is in r7 */
-
-        .align  2
-        .globl  caml_c_call
-caml_c_call:
-        CFI_STARTPROC
-        PROFILE
-    /* Record lowest stack address and return address */
-        ldr     r5, =caml_last_return_address
-        ldr     r6, =caml_bottom_of_stack
+         .align  2
+        .globl  G(caml_call_gc)
+				.thumb_func G(caml_call_gc)
+G(caml_call_gc):
+         CFI_STARTPROC
+     /* Record return address */
+        ldr     r12, LBL(caml_last_return_address)
+         str     lr, [r12]
+LBL(caml_call_gc):
+     /* Record lowest stack address */
+        ldr     r12, LBL(caml_bottom_of_stack)
+         str     sp, [r12]
+     /* Save caller floating-point registers on the stack */
+         vpush   {d0-d7}; CFI_ADJUST(64)
+     /* Save integer registers and return address on the stack */
+         push    {r0-r7,r12,lr}; CFI_ADJUST(40)
+     /* Store pointer to saved integer registers in caml_gc_regs */
+        ldr     r12, LBL(caml_gc_regs)
+         str     sp, [r12]
+     /* Save current allocation pointer for debugging purposes */
+        ldr     alloc_limit, LBL(caml_young_ptr)
+         str     alloc_ptr, [alloc_limit]
+     /* Save trap pointer in case an exception is raised during GC */
+        ldr     r12, LBL(caml_exception_pointer)
+         str     trap_ptr, [r12]
+     /* Call the garbage collector */
+        bl      G(caml_garbage_collection)
+     /* Restore integer registers and return address from the stack */
+         pop     {r0-r7,r12,lr}; CFI_ADJUST(-40)
+     /* Restore floating-point registers from the stack */
+         vpop    {d0-d7}; CFI_ADJUST(-64)
+     /* Reload new allocation pointer and limit */
+     /* alloc_limit still points to caml_young_ptr */
+        ldr     r12, LBL(caml_young_limit)
+         ldr     alloc_ptr, [alloc_limit]
+         ldr     alloc_limit, [r12]
+     /* Return to caller */
+         bx      lr
+         CFI_ENDPROC
+
+         .align  2
+        .globl  G(caml_alloc1)
+				.thumb_func G(caml_alloc1)
+G(caml_alloc1):
+         CFI_STARTPROC
+LBL(caml_alloc1):
+         sub     alloc_ptr, alloc_ptr, 8
+         cmp     alloc_ptr, alloc_limit
+         bcc     1f
+         bx      lr
+ 1:  /* Record return address */
+        ldr     r7, LBL(caml_last_return_address)
+         str     lr, [r7]
+     /* Call GC (preserves r7) */
+        bl      LBL(caml_call_gc)
+     /* Restore return address */
+         ldr     lr, [r7]
+     /* Try again */
+        b       LBL(caml_alloc1)
+         CFI_ENDPROC
+
+         .align  2
+        .globl  G(caml_alloc2)
+				.thumb_func G(caml_alloc2)
+G(caml_alloc2):
+         CFI_STARTPROC
+LBL(caml_alloc2):
+         sub     alloc_ptr, alloc_ptr, 12
+         cmp     alloc_ptr, alloc_limit
+         bcc     1f
+         bx      lr
+ 1:  /* Record return address */
+        ldr     r7, LBL(caml_last_return_address)
+         str     lr, [r7]
+     /* Call GC (preserves r7) */
+        bl      LBL(caml_call_gc)
+     /* Restore return address */
+         ldr     lr, [r7]
+     /* Try again */
+        b       LBL(caml_alloc2)
+         CFI_ENDPROC
+
+         .align  2
+        .globl  _caml_alloc3
+				.thumb_func _caml_alloc3
+_caml_alloc3:
+         CFI_STARTPROC
+Lcaml_alloc3:
+         sub     alloc_ptr, alloc_ptr, 16
+         cmp     alloc_ptr, alloc_limit
+         bcc     1f
+         bx      lr
+ 1:  /* Record return address */
+        ldr     r7, Lcaml_last_return_address
+         str     lr, [r7]
+     /* Call GC (preserves r7) */
+        bl      Lcaml_call_gc
+     /* Restore return address */
+         ldr     lr, [r7]
+     /* Try again */
+        b       Lcaml_alloc3
+         CFI_ENDPROC
+
+         .align  2
+        .globl  _caml_allocN
+				.thumb_func _caml_allocN
+_caml_allocN:
+         CFI_STARTPROC
+Lcaml_allocN:
+         sub     alloc_ptr, alloc_ptr, r7
+         cmp     alloc_ptr, alloc_limit
+         bcc     1f
+         bx      lr
+ 1:  /* Record return address */
+        ldr     r12, Lcaml_last_return_address
+         str     lr, [r12]
+     /* Call GC (preserves r7) */
+        bl      Lcaml_call_gc
+     /* Restore return address */
+        ldr     r12, Lcaml_last_return_address
+         ldr     lr, [r12]
+     /* Try again */
+        b       Lcaml_allocN
+         CFI_ENDPROC
+
+ /* Call a C function from OCaml */
+ /* Function to call is in r7 */
+
+         .align  2
+        .globl  _caml_c_call
+				.thumb_func _caml_c_call
+_caml_c_call:
+         CFI_STARTPROC
+     /* Record lowest stack address and return address */
+        ldr     r5, Lcaml_last_return_address
+        ldr     r6, Lcaml_bottom_of_stack
         str     lr, [r5]
         str     sp, [r6]
-    /* Preserve return address in callee-save register r4 */
-        mov     r4, lr
-    /* Make the exception handler alloc ptr available to the C code */
-        ldr     r5, =caml_young_ptr
-        ldr     r6, =caml_exception_pointer
+     /* Preserve return address in callee-save register r4 */
+         mov     r4, lr
+     /* Make the exception handler alloc ptr available to the C code */
+        ldr     r5, Lcaml_young_ptr
+        ldr     r6, Lcaml_exception_pointer
         str     alloc_ptr, [r5]
         str     trap_ptr, [r6]
-    /* Call the function */
+     /* Call the function */
         blx     r7
-    /* Reload alloc ptr and alloc limit */
-        ldr     r6, =caml_young_limit
+     /* Reload alloc ptr and alloc limit */
+        ldr     r6, Lcaml_young_limit
         ldr     alloc_ptr, [r5]         /* r5 still points to caml_young_ptr */
         ldr     alloc_limit, [r6]
-    /* Return */
-        bx      r4
-        CFI_ENDPROC
-        .type   caml_c_call, %function
-        .size   caml_c_call, .-caml_c_call
-
-/* Start the OCaml program */
-
-        .align  2
-        .globl  caml_start_program
-caml_start_program:
-        CFI_STARTPROC
-        PROFILE
-        ldr     r12, =caml_program
+     /* Return */
+         bx      r4
+         CFI_ENDPROC
+
+ /* Start the OCaml program */
+
+         .align  2
+        .globl  _caml_start_program
+				.thumb_func _caml_start_program
+_caml_start_program:
+         CFI_STARTPROC
+        ldr     r12, Lcaml_program
+
+ /* Code shared with caml_callback* */
+ /* Address of OCaml code to call is in r12 */
+ /* Arguments to the OCaml code are in r0...r3 */
+
+Ljump_to_caml:
+ #if defined(SYS_linux_eabihf)
+     /* Save callee-save floating-point registers */
+         vpush   {d8-d15}; CFI_ADJUST(64)
 
-/* Code shared with caml_callback* */
-/* Address of OCaml code to call is in r12 */
-/* Arguments to the OCaml code are in r0...r3 */
-
-.Ljump_to_caml:
-#if defined(SYS_linux_eabihf)
-    /* Save callee-save floating-point registers */
-        vpush   {d8-d15}; CFI_ADJUST(64)
 #endif
     /* Save return address and callee-save registers */
         push    {r4-r8,r10,r11,lr}; CFI_ADJUST(32)      /* 8-byte alignment */
     /* Setup a callback link on the stack */
         sub     sp, sp, 16; CFI_ADJUST(16)              /* 8-byte alignment */
-        ldr     r4, =caml_bottom_of_stack
-        ldr     r5, =caml_last_return_address
-        ldr     r6, =caml_gc_regs
+        ldr     r4, Lcaml_bottom_of_stack
+        ldr     r5, Lcaml_last_return_address
+        ldr     r6, Lcaml_gc_regs
         ldr     r4, [r4]
         ldr     r5, [r5]
         ldr     r6, [r6]
         str     r4, [sp, 0]
         str     r5, [sp, 4]
-        str     r6, [sp, 8]
-    /* Setup a trap frame to catch exceptions escaping the OCaml code */
-        sub     sp, sp, 8; CFI_ADJUST(8)
-        ldr     r6, =caml_exception_pointer
-        ldr     r5, =.Ltrap_handler
-        ldr     r4, [r6]
-        str     r4, [sp, 0]
-        str     r5, [sp, 4]
-        mov     trap_ptr, sp
-    /* Reload allocation pointers */
-        ldr     r4, =caml_young_ptr
-        ldr     alloc_ptr, [r4]
-        ldr     r4, =caml_young_limit
-        ldr     alloc_limit, [r4]
-    /* Call the OCaml code */
-        blx     r12
-.Lcaml_retaddr:
-    /* Pop the trap frame, restoring caml_exception_pointer */
-        ldr     r4, =caml_exception_pointer
-        ldr     r5, [sp, 0]
-        str     r5, [r4]
-        add     sp, sp, 8; CFI_ADJUST(-8)
-    /* Pop the callback link, restoring the global variables */
-.Lreturn_result:
-        ldr     r4, =caml_bottom_of_stack
-        ldr     r5, [sp, 0]
-        str     r5, [r4]
-        ldr     r4, =caml_last_return_address
-        ldr     r5, [sp, 4]
-        str     r5, [r4]
-        ldr     r4, =caml_gc_regs
-        ldr     r5, [sp, 8]
-        str     r5, [r4]
-        add     sp, sp, 16; CFI_ADJUST(-16)
-    /* Update allocation pointer */
-        ldr     r4, =caml_young_ptr
-        str     alloc_ptr, [r4]
-    /* Reload callee-save registers and return address */
-        pop     {r4-r8,r10,r11,lr}; CFI_ADJUST(-32)
+         str     r6, [sp, 8]
+     /* Setup a trap frame to catch exceptions escaping the OCaml code */
+         sub     sp, sp, 8; CFI_ADJUST(8)
+        ldr     r6, Lcaml_exception_pointer
+        ldr     r5, LLtrap_handler
+         ldr     r4, [r6]
+         str     r4, [sp, 0]
+         str     r5, [sp, 4]
+         mov     trap_ptr, sp
+     /* Reload allocation pointers */
+        ldr     r4, Lcaml_young_ptr
+         ldr     alloc_ptr, [r4]
+        ldr     r4, Lcaml_young_limit
+         ldr     alloc_limit, [r4]
+     /* Call the OCaml code */
+         blx     r12
+Lcaml_retaddr:
+     /* Pop the trap frame, restoring caml_exception_pointer */
+        ldr     r4, Lcaml_exception_pointer
+         ldr     r5, [sp, 0]
+         str     r5, [r4]
+         add     sp, sp, 8; CFI_ADJUST(-8)
+     /* Pop the callback link, restoring the global variables */
+Lreturn_result:
+        ldr     r4, Lcaml_bottom_of_stack
+         ldr     r5, [sp, 0]
+         str     r5, [r4]
+        ldr     r4, Lcaml_last_return_address
+         ldr     r5, [sp, 4]
+         str     r5, [r4]
+        ldr     r4, Lcaml_gc_regs
+         ldr     r5, [sp, 8]
+         str     r5, [r4]
+         add     sp, sp, 16; CFI_ADJUST(-16)
+     /* Update allocation pointer */
+        ldr     r4, Lcaml_young_ptr
+         str     alloc_ptr, [r4]
+     /* Reload callee-save registers and return address */
+         pop     {r4-r8,r10,r11,lr}; CFI_ADJUST(-32)
 #if defined(SYS_linux_eabihf)
     /* Reload callee-save floating-point registers */
         vpop    {d8-d15}; CFI_ADJUST(-64)
-#endif
-        bx      lr
-        CFI_ENDPROC
-        .type   .Lcaml_retaddr, %function
-        .size   .Lcaml_retaddr, .-.Lcaml_retaddr
-        .type   caml_start_program, %function
-        .size   caml_start_program, .-caml_start_program
-
-/* The trap handler */
+ #endif
+         bx      lr
+         CFI_ENDPROC
+
+ /* The trap handler */
+
+         .align  2
+Ltrap_handler:
+         CFI_STARTPROC
+     /* Save exception pointer */
+        ldr     r12, Lcaml_exception_pointer
+         str     trap_ptr, [r12]
+     /* Encode exception bucket as an exception result */
+         orr     r0, r0, 2
+     /* Return it */
+        b       Lreturn_result
+         CFI_ENDPROC
+
+ /* Raise an exception from OCaml */
+
+         .align  2
+        .globl  _caml_raise_exn
+				.thumb_func _caml_raise_exn
+_caml_raise_exn:
+         CFI_STARTPROC
+     /* Test if backtrace is active */
+        ldr     r1, Lcaml_backtrace_active
+         ldr     r1, [r1]
+         cbz     r1, 1f
+     /* Preserve exception bucket in callee-save register r4 */
 
-        .align  2
-.Ltrap_handler:
-        CFI_STARTPROC
-    /* Save exception pointer */
-        ldr     r12, =caml_exception_pointer
-        str     trap_ptr, [r12]
-    /* Encode exception bucket as an exception result */
-        orr     r0, r0, 2
-    /* Return it */
-        b       .Lreturn_result
-        CFI_ENDPROC
-        .type   .Ltrap_handler, %function
-        .size   .Ltrap_handler, .-.Ltrap_handler
-
-/* Raise an exception from OCaml */
-
-        .align  2
-        .globl  caml_raise_exn
-caml_raise_exn:
-        CFI_STARTPROC
-        PROFILE
-    /* Test if backtrace is active */
-        ldr     r1, =caml_backtrace_active
-        ldr     r1, [r1]
-        cbz     r1, 1f
-    /* Preserve exception bucket in callee-save register r4 */
         mov     r4, r0
     /* Stash the backtrace */
         mov     r1, lr                          /* arg2: pc of raise */
         mov     r2, sp                          /* arg3: sp of raise */
         mov     r3, trap_ptr                    /* arg4: sp of handler */
-        bl      caml_stash_backtrace
+        bl      _caml_stash_backtrace
     /* Restore exception bucket */
         mov     r0, r4
 1:  /* Cut stack at current trap handler */
         mov     sp, trap_ptr
-    /* Pop previous handler and addr of trap, and jump to it */
-        pop     {trap_ptr, pc}
-        CFI_ENDPROC
-        .type   caml_raise_exn, %function
-        .size   caml_raise_exn, .-caml_raise_exn
-
-/* Raise an exception from C */
+     /* Pop previous handler and addr of trap, and jump to it */
+         pop     {trap_ptr, pc}
+         CFI_ENDPROC
+
+ /* Raise an exception from C */
+
+         .align  2
+        .globl  _caml_raise_exception
+				.thumb_func _caml_raise_exception
+_caml_raise_exception:
+         CFI_STARTPROC
+     /* Reload trap ptr, alloc ptr and alloc limit */
+        ldr     trap_ptr, Lcaml_exception_pointer
+        ldr     alloc_ptr, Lcaml_young_ptr
+        ldr     alloc_limit, Lcaml_young_limit
+         ldr     trap_ptr, [trap_ptr]
+         ldr     alloc_ptr, [alloc_ptr]
+         ldr     alloc_limit, [alloc_limit]
+     /* Test if backtrace is active */
+        ldr     r1, Lcaml_backtrace_active
+         ldr     r1, [r1]
+         cbz     r1, 1f
+     /* Preserve exception bucket in callee-save register r4 */
+         mov     r4, r0
+        ldr     r1, Lcaml_last_return_address   /* arg2: pc of raise */
+         ldr     r1, [r1]
+        ldr     r2, Lcaml_bottom_of_stack       /* arg3: sp of raise */
+         ldr     r2, [r2]
+         mov     r3, trap_ptr                    /* arg4: sp of handler */
+        bl      _caml_stash_backtrace
+     /* Restore exception bucket */
+         mov     r0, r4
+ 1:  /* Cut stack at current trap handler */
 
-        .align  2
-        .globl  caml_raise_exception
-caml_raise_exception:
-        CFI_STARTPROC
-        PROFILE
-    /* Reload trap ptr, alloc ptr and alloc limit */
-        ldr     trap_ptr, =caml_exception_pointer
-        ldr     alloc_ptr, =caml_young_ptr
-        ldr     alloc_limit, =caml_young_limit
-        ldr     trap_ptr, [trap_ptr]
-        ldr     alloc_ptr, [alloc_ptr]
-        ldr     alloc_limit, [alloc_limit]
-    /* Test if backtrace is active */
-        ldr     r1, =caml_backtrace_active
-        ldr     r1, [r1]
-        cbz     r1, 1f
-    /* Preserve exception bucket in callee-save register r4 */
-        mov     r4, r0
-        ldr     r1, =caml_last_return_address   /* arg2: pc of raise */
-        ldr     r1, [r1]
-        ldr     r2, =caml_bottom_of_stack       /* arg3: sp of raise */
-        ldr     r2, [r2]
-        mov     r3, trap_ptr                    /* arg4: sp of handler */
-        bl      caml_stash_backtrace
-    /* Restore exception bucket */
-        mov     r0, r4
-1:  /* Cut stack at current trap handler */
         mov     sp, trap_ptr
-    /* Pop previous handler and addr of trap, and jump to it */
-        pop     {trap_ptr, pc}
-        CFI_ENDPROC
-        .type   caml_raise_exception, %function
-        .size   caml_raise_exception, .-caml_raise_exception
+     /* Pop previous handler and addr of trap, and jump to it */
+         pop     {trap_ptr, pc}
+         CFI_ENDPROC
 
 /* Callback from C to OCaml */
 
         .align  2
-        .globl  caml_callback_exn
-caml_callback_exn:
+        .globl  _caml_callback_exn
+		.thumb_func _caml_callback_exn
+_caml_callback_exn:
         CFI_STARTPROC
-        PROFILE
     /* Initial shuffling of arguments (r0 = closure, r1 = first arg) */
         mov     r12, r0
         mov     r0, r1          /* r0 = first arg */
         mov     r1, r12         /* r1 = closure environment */
         ldr     r12, [r12]      /* code pointer */
-        b       .Ljump_to_caml
+        b       Ljump_to_caml
         CFI_ENDPROC
-        .type   caml_callback_exn, %function
-        .size   caml_callback_exn, .-caml_callback_exn
 
         .align  2
-        .globl  caml_callback2_exn
-caml_callback2_exn:
+        .globl  _caml_callback2_exn
+		.thumb_func _caml_callback2_exn
+_caml_callback2_exn:
         CFI_STARTPROC
-        PROFILE
     /* Initial shuffling of arguments (r0 = closure, r1 = arg1, r2 = arg2) */
         mov     r12, r0
         mov     r0, r1          /* r0 = first arg */
         mov     r1, r2          /* r1 = second arg */
         mov     r2, r12         /* r2 = closure environment */
-        ldr     r12, =caml_apply2
-        b       .Ljump_to_caml
+        ldr     r12, Lcaml_apply2
+        b       Ljump_to_caml
         CFI_ENDPROC
-        .type   caml_callback2_exn, %function
-        .size   caml_callback2_exn, .-caml_callback2_exn
 
         .align  2
-        .globl  caml_callback3_exn
-caml_callback3_exn:
+        .globl  _caml_callback3_exn
+		.thumb_func _caml_callback3_exn
+_caml_callback3_exn:
         CFI_STARTPROC
-        PROFILE
     /* Initial shuffling of arguments */
     /* (r0 = closure, r1 = arg1, r2 = arg2, r3 = arg3) */
         mov     r12, r0
@@ -463,38 +393,47 @@
         mov     r1, r2          /* r1 = second arg */
         mov     r2, r3          /* r2 = third arg */
         mov     r3, r12         /* r3 = closure environment */
-        ldr     r12, =caml_apply3
-        b       .Ljump_to_caml
-        CFI_ENDPROC
-        .type   caml_callback3_exn, %function
-        .size   caml_callback3_exn, .-caml_callback3_exn
+        ldr     r12, Lcaml_apply3
+        b       Ljump_to_caml
+        CFI_ENDPROC 
+
+         .align  2
+        .globl  _caml_ml_array_bound_error
+				.thumb_func _caml_ml_array_bound_error
+_caml_ml_array_bound_error:
+         CFI_STARTPROC
+     /* Load address of [caml_array_bound_error] in r7 */
+        ldr     r7, Lcaml_array_bound_error
+     /* Call that function */
+        b       _caml_c_call
+         CFI_ENDPROC
+
+        .globl  _caml_system__code_end
+_caml_system__code_end:
 
-        .align  2
-        .globl  caml_ml_array_bound_error
-caml_ml_array_bound_error:
-        CFI_STARTPROC
-        PROFILE
-    /* Load address of [caml_array_bound_error] in r7 */
-        ldr     r7, =caml_array_bound_error
-    /* Call that function */
-        b       caml_c_call
-        CFI_ENDPROC
-        .type   caml_ml_array_bound_error, %function
-        .size   caml_ml_array_bound_error, .-caml_ml_array_bound_error
 
-        .globl  caml_system__code_end
-caml_system__code_end:
 
-/* GC roots for callback */
 
-        .data
-        .align  2
-        .globl  caml_system__frametable
-caml_system__frametable:
-        .word   1               /* one descriptor */
-        .word   .Lcaml_retaddr  /* return address into callback */
-        .short  -1              /* negative frame size => use callback link */
-        .short  0               /* no roots */
-        .align  2
-        .type   caml_system__frametable, %object
-        .size   caml_system__frametable, .-caml_system__frametable
+ /* GC roots for callback */
+
+	LBL(caml_last_return_address): .word G(caml_last_return_address)
+	LBL(caml_backtrace_active): .word G(caml_backtrace_active)
+	LBL(caml_bottom_of_stack): .word G(caml_bottom_of_stack)
+	LBL(caml_gc_regs): .word G(caml_gc_regs)
+	LBL(caml_young_ptr): .word G(caml_young_ptr)
+	LBL(caml_young_limit): .word G(caml_young_limit)
+	LBL(caml_exception_pointer): .word G(caml_exception_pointer)
+	LBL(caml_program):                .word G(caml_program)
+	LBL(Ltrap_handler):               .word LBL(trap_handler)
+	LBL(caml_apply2):                 .word G(caml_apply2)
+  LBL(caml_apply3):                 .word G(caml_apply3)
+  LBL(caml_array_bound_error):      .word G(caml_array_bound_error)
+
+         .align  2
+        .globl  _caml_system__frametable
+_caml_system__frametable:
+         .word   1               /* one descriptor */
+        .word   Lcaml_retaddr  /* return address into callback */
+         .short  -1              /* negative frame size => use callback link */
+         .short  0               /* no roots */
+         .align  2
diff -urN ocaml-4.02.1-clean/byterun/Makefile.common ocaml-4.02.1-ios/byterun/Makefile.common
--- ocaml-4.02.1-clean/byterun/Makefile.common	2014-07-22 00:34:38.000000000 +0400
+++ ocaml-4.02.1-ios/byterun/Makefile.common	2014-10-29 12:47:20.000000000 +0300
@@ -67,6 +67,13 @@
 	cp ld.conf $(INSTALL_LIBDIR)/ld.conf
 .PHONY: install
 
+installopt:
+	if test -d $(LIBDIR)/caml; then : ; else mkdir $(LIBDIR)/caml; fi
+	for i in $(PUBLIC_INCLUDES); do \
+		sed -f ../tools/cleanup-header $$i > $(LIBDIR)/caml/$$i; \
+  done
+.PHONY: installopt
+
 install:: install-$(RUNTIMED)
 
 install-noruntimed:
diff -urN ocaml-4.02.1-clean/config/Makefile ocaml-4.02.1-ios/config/Makefile
--- ocaml-4.02.1-clean/config/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.02.1-ios/config/Makefile	2014-10-29 12:47:20.000000000 +0300
@@ -0,0 +1,76 @@
+PREFIX=/usr/local/ocaml/ios
+PLATFORM=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer
+SDK=$(PLATFORM)/SDKs/iPhoneOS8.0.sdk
+BINDIR=$(PREFIX)/bin
+LIBDIR=$(PREFIX)/lib
+STUBLIBDIR=$(LIBDIR)/stublibs
+MANDIR=$(PREFIX)/man
+MANEXT=1
+RANLIB=$(PLATFORM)/usr/bin/ranlib
+RANLIBCMD=$(RANLIB)
+ARCMD=$(PLATFORM)/usr/bin/ar
+SHARPBANGSCRIPTS=true
+BNG_ARCH=generic
+BNG_ASM_LEVEL=0
+PTHREAD_LINK=-cclib -pthread
+LIBBFD_LINK=-lbfd -ldl -liberty -lz
+BYTECC=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch armv7 -isysroot $(SDK) -miphoneos-version-min=5.1 -fmessage-length=0 -std=gnu99 -fpascal-strings -Os -fstrict-aliasing -fvisibility=hidden
+#
+BYTECCCOMPOPTS=-Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D__ARM_EABI__ -g
+BYTECCLINKOPTS= -Wl
+BYTECCLIBS= -lpthread
+BYTECCRPATH=-Wl,-rpath,
+EXE=
+SUPPORTS_SHARED_LIBRARIES=false
+#SHAREDCCCOMPOPTS=-fPIC
+MKSHAREDLIBRPATH=-Wl,-rpath,
+NATDYNLINKOPTS=-Wl
+SYSLIB=-l$(1)
+#ml let syslib x = "-l"^x;;
+
+### How to build a static library
+MKLIB=$(ARCMD) rc $(1) $(2); $(RANLIB) $(1)
+#ml let mklib out files opts = Printf.sprintf "ar rc %s %s %s; ranlib %s" out opts files out;;
+ARCH=arm
+MODEL=armv7
+SYSTEM=linux_eabihf
+NATIVECC=$(BYTECC)
+NATIVECCCOMPOPTS=-Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D__ARM_EABI__ -g
+# -gdwarf-2 -fexceptions
+NATIVECCPROFOPTS=-Wall -D_FILE_OFFSET_BITS=64 -D_REENTRANT -D__ARM_EABI__
+NATIVECCLINKOPTS=
+NATIVECCRPATH=-Wl,-rpath,
+NATIVECCLIBS= -lm  -ldl
+ASM=$(NATIVECC) -D__ARM_EABI__ -c
+ASPP=$(ASM)
+ASPPPROFFLAGS=-DPROFILING
+PROFILING=noprof
+DYNLINKOPTS= -ldl
+OTHERLIBRARIES=unix str num dynlink bigarray threads systhreads
+DEBUGGER=ocamldebugger
+CC_PROFILE=-pg
+SYSTHREAD_SUPPORT=false
+PARTIALLD=ld -r
+PACKLD=$(PARTIALLD) $(NATIVECCLINKOPTS) -o\ 
+DLLCCCOMPOPTS=
+IFLEXDIR=
+O=o
+A=a
+SO=so
+EXT_OBJ=.o
+EXT_ASM=.s
+EXT_LIB=.a
+EXT_DLL=.so
+EXTRALIBS=
+CCOMPTYPE=cc
+TOOLCHAIN=cc
+NATDYNLINK=false
+CMXS=cmxa
+MKEXE=$(NATIVECC) -miphoneos-version-min=5.1 -dead_strip -fobjc-link-runtime
+MKDLL=$(MKEXE)  -bundle -flat_namespace -undefined suppress
+MKMAINDLL=$(MKDLL)
+RUNTIMED=noruntimed
+ASM_CFI_SUPPORTED=true
+WITH_FRAME_POINTERS=false
+UNIX_OR_WIN32=unix
+UNIXLIB=unix
diff -urN ocaml-4.02.1-clean/config/m.h ocaml-4.02.1-ios/config/m.h
--- ocaml-4.02.1-clean/config/m.h	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.02.1-ios/config/m.h	2014-10-29 12:47:20.000000000 +0300
@@ -0,0 +1,16 @@
+#ifndef __PIC__
+#  define ARCH_CODE32
+#endif
+#undef ARCH_SIXTYFOUR
+#define SIZEOF_INT 4
+#define SIZEOF_LONG 4
+#define SIZEOF_PTR 4
+#define SIZEOF_SHORT 2
+#define ARCH_INT64_TYPE long long
+#define ARCH_UINT64_TYPE unsigned long long
+#define ARCH_INT64_PRINTF_FORMAT "ll"
+#undef ARCH_BIG_ENDIAN
+#undef ARCH_ALIGN_DOUBLE
+#undef ARCH_ALIGN_INT64
+#undef NONSTANDARD_DIV_MOD
+#define ASM_CFI_SUPPORTED
diff -urN ocaml-4.02.1-clean/config/s.h ocaml-4.02.1-ios/config/s.h
--- ocaml-4.02.1-clean/config/s.h	1970-01-01 03:00:00.000000000 +0300
+++ ocaml-4.02.1-ios/config/s.h	2014-10-29 12:47:20.000000000 +0300
@@ -0,0 +1,51 @@
+#define OCAML_OS_TYPE "Unix"
+#define OCAML_STDLIB_DIR "/usr/local/ocaml/ios/4.00/lib"
+#define POSIX_SIGNALS
+#define HAS_C99_FLOAT_OPS
+#define HAS_GETRUSAGE
+#define HAS_TIMES
+#undef HAS_TERMCAP
+#define HAS_SOCKETS
+#define HAS_SOCKLEN_T
+#define HAS_INET_ATON
+#define HAS_IPV6
+#define HAS_UNISTD
+#define HAS_OFF_T
+#define HAS_DIRENT
+#define HAS_REWINDDIR
+#define HAS_LOCKF
+#define HAS_MKFIFO
+#define HAS_GETCWD
+#define HAS_GETWD
+#define HAS_GETPRIORITY
+#define HAS_UTIME
+#define HAS_UTIMES
+#define HAS_DUP2
+#define HAS_FCHMOD
+#define HAS_TRUNCATE
+#define HAS_SYS_SELECT_H
+#define HAS_SELECT
+#define HAS_SYMLINK
+#define HAS_WAITPID
+#define HAS_WAIT4
+#define HAS_GETGROUPS
+#define HAS_SETGROUPS
+#define HAS_INITGROUPS
+#define HAS_TERMIOS
+#define HAS_ASYNC_IO
+#define HAS_SETITIMER
+#define HAS_GETHOSTNAME
+#define HAS_UNAME
+#define HAS_GETTIMEOFDAY
+#define HAS_MKTIME
+#define HAS_SETSID
+#define HAS_PUTENV
+#define HAS_LOCALE
+#undef SUPPORT_DYNAMIC_LINKING
+#define HAS_MMAP
+#define HAS_PWRITE
+#undef HAS_GETHOSTBYNAME_R
+#undef HAS_GETHOSTBYADDR_R
+#undef HAS_STACK_OVERFLOW_DETECTION
+#define HAS_SIGWAIT
+#undef HAS_LIBBFD
diff -urN ocaml-4.02.1-clean/driver/optmain.ml ocaml-4.02.1-ios/driver/optmain.ml
--- ocaml-4.02.1-clean/driver/optmain.ml	2014-08-28 20:24:52.000000000 +0400
+++ ocaml-4.02.1-ios/driver/optmain.ml	2014-10-29 12:47:20.000000000 +0300
@@ -45,11 +45,17 @@
     ccobjs := name :: !ccobjs
   else if Filename.check_suffix name ".c" then begin
     Optcompile.c_file name;
-    ccobjs := (Filename.chop_suffix (Filename.basename name) ".c" ^ ext_obj)
+     ccobjs := (Filename.chop_suffix (Filename.basename name) ".c" ^ ext_obj)
+               :: !ccobjs
+   end
+  else if Filename.check_suffix name ".m" then begin
+    Optcompile.c_file name;
+    ccobjs := (Filename.chop_suffix (Filename.basename name) ".m" ^ ext_obj)
               :: !ccobjs
   end
-  else
-    raise(Arg.Bad("don't know what to do with " ^ name))
+   else
+     raise(Arg.Bad("don't know what to do with " ^ name))
+
 
 let usage = "Usage: ocamlopt <options> <files>\nOptions are:"
 
diff -urN ocaml-4.02.1-clean/otherlibs/Makefile ocaml-4.02.1-ios/otherlibs/Makefile
--- ocaml-4.02.1-clean/otherlibs/Makefile	2014-04-12 14:17:02.000000000 +0400
+++ ocaml-4.02.1-ios/otherlibs/Makefile	2014-10-29 12:47:20.000000000 +0300
@@ -13,8 +13,8 @@
 
 # Common Makefile for otherlibs on the Unix ports
 
-CAMLC=$(ROOTDIR)/boot/ocamlrun $(ROOTDIR)/ocamlc -nostdlib -I $(ROOTDIR)/stdlib
-CAMLOPT=$(ROOTDIR)/boot/ocamlrun $(ROOTDIR)/ocamlopt -nostdlib \
+CAMLC=ocamlc.opt -nostdlib -I $(ROOTDIR)/stdlib
+CAMLOPT=$(ROOTDIR)/ocamlopt.opt -nostdlib \
         -I $(ROOTDIR)/stdlib
 CFLAGS=-I$(ROOTDIR)/byterun -O $(SHAREDCCCOMPOPTS) $(EXTRACFLAGS)
 
diff -urN ocaml-4.02.1-clean/otherlibs/Makefile.shared ocaml-4.02.1-ios/otherlibs/Makefile.shared
--- ocaml-4.02.1-clean/otherlibs/Makefile.shared	2014-04-29 15:56:17.000000000 +0400
+++ ocaml-4.02.1-ios/otherlibs/Makefile.shared	2014-10-29 12:47:20.000000000 +0300
@@ -16,12 +16,14 @@
 ROOTDIR=../..
 include $(ROOTDIR)/config/Makefile
 
-# Compilation options
+ # Compilation options
 CC=$(BYTECC)
-CAMLRUN=$(ROOTDIR)/boot/ocamlrun
-COMPFLAGS=-w +33..39 -warn-error A -bin-annot -g -safe-string $(EXTRACAMLFLAGS)
+CAMLRUN=ocamlrun
+COMPFLAGS=-w +33..39 -warn-error A -g $(EXTRACAMLFLAGS)
 MKLIB=$(CAMLRUN) $(ROOTDIR)/tools/ocamlmklib
 
+
+
 # Variables to be defined by individual libraries:
 #LIBNAME=
 #CLIBNAME=
@@ -65,12 +67,16 @@
 	cp lib$(CLIBNAME).$(A) $(INSTALL_LIBDIR)/
 	cd $(INSTALL_LIBDIR); $(RANLIB) lib$(CLIBNAME).$(A)
 	cp $(LIBNAME).cma $(CMIFILES) $(CMIFILES:.cmi=.mli) $(INSTALL_LIBDIR)/
-	if test -n "$(HEADERS)"; then cp $(HEADERS) $(INSTALL_LIBDIR)/caml/; fi
+	if test -n "$(HEADERS)"; then cp $(HEADERS) $(LIBDIR)/caml/; fi
 
 installopt:
-	cp $(CAMLOBJS_NAT) $(LIBNAME).cmxa $(LIBNAME).$(A) $(INSTALL_LIBDIR)/
-	cd $(INSTALL_LIBDIR); $(RANLIB) $(LIBNAME).a
-	if test -f $(LIBNAME).cmxs; then cp $(LIBNAME).cmxs $(INSTALL_LIBDIR)/; fi
+	cp lib$(CLIBNAME).$(A) $(LIBDIR)/
+	cd $(LIBDIR); $(RANLIB) lib$(CLIBNAME).$(A)
+	cp $(CAMLOBJS_NAT) $(LIBNAME).cmxa $(LIBNAME).$(A) $(LIBDIR)/
+	cd $(LIBDIR); $(RANLIB) $(LIBNAME).a
+	cp $(CMIFILES) $(CMIFILES:.cmi=.mli) $(LIBDIR)/
+	if test -f $(LIBNAME).cmxs; then cp $(LIBNAME).cmxs $(LIBDIR)/; fi
+	if test -n "$(HEADERS)"; then cp $(HEADERS) $(LIBDIR)/caml/; fi
 
 partialclean:
 	rm -f *.cm*
diff -urN ocaml-4.02.1-clean/otherlibs/dynlink/Makefile ocaml-4.02.1-ios/otherlibs/dynlink/Makefile
--- ocaml-4.02.1-clean/otherlibs/dynlink/Makefile	2014-04-29 15:56:17.000000000 +0400
+++ ocaml-4.02.1-ios/otherlibs/dynlink/Makefile	2014-10-29 12:47:20.000000000 +0300
@@ -15,10 +15,11 @@
 
 include ../../config/Makefile
 
-ROOTDIR   = ../..
-OCAMLRUN  = $(ROOTDIR)/boot/ocamlrun
-OCAMLC    = $(OCAMLRUN) $(ROOTDIR)/ocamlc -nostdlib -I $(ROOTDIR)/stdlib
-OCAMLOPT  = $(OCAMLRUN) $(ROOTDIR)/ocamlopt -nostdlib -I $(ROOTDIR)/stdlib
+CAMLC=ocamlc.opt
+CAMLOPT=../../ocamlopt.opt
+INCLUDES=-I ../../utils -I ../../typing -I ../../bytecomp -I ../../asmcomp
+COMPFLAGS=-w +33..39 -warn-error A -I ../../stdlib $(INCLUDES)
+
 
 INCLUDES=-I ../../utils -I ../../typing -I ../../bytecomp -I ../../asmcomp
 COMPFLAGS=-w +33..39 -warn-error A -bin-annot -safe-string \
@@ -51,25 +52,25 @@
 allopt: dynlink.cmxa
 
 dynlink.cma: $(OBJS)
-	$(OCAMLC) $(COMPFLAGS) -ccopt "$(NATDYNLINKOPTS)" -a -o dynlink.cma \
+	$(CAMLC) $(COMPFLAGS) -ccopt "$(NATDYNLINKOPTS)" -a -o dynlink.cma \
 	         $(OBJS)
 
 dynlink.cmxa: $(NATOBJS)
-	$(OCAMLOPT) $(COMPFLAGS) -ccopt "$(NATDYNLINKOPTS)" -a -o dynlink.cmxa \
+	$(CAMLOPT) $(COMPFLAGS) -ccopt "$(NATDYNLINKOPTS)" -a -o dynlink.cmxa \
 	           $(NATOBJS)
 
 dynlinkaux.cmo: $(COMPILEROBJS)
-	$(OCAMLC) $(COMPFLAGS) -pack -o dynlinkaux.cmo $(COMPILEROBJS)
+	$(CAMLC) $(COMPFLAGS) -pack -o dynlinkaux.cmo $(COMPILEROBJS)
 
 dynlinkaux.cmi: dynlinkaux.cmo
 
 dynlink.cmx: dynlink.cmi natdynlink.ml
 	cp natdynlink.ml  dynlink.mlopt
-	$(OCAMLOPT) -c $(COMPFLAGS) -impl dynlink.mlopt
+	$(CAMLOPT) -c $(COMPFLAGS) -impl dynlink.mlopt
 	rm -f dynlink.mlopt
 
 extract_crc: dynlink.cma extract_crc.cmo
-	$(OCAMLC) $(COMPFLAGS) -o extract_crc dynlink.cma extract_crc.cmo
+	$(CAMLC) $(COMPFLAGS) -o extract_crc dynlink.cma extract_crc.cmo
 
 INSTALL_LIBDIR=$(DESTDIR)$(LIBDIR)
 
@@ -92,13 +93,13 @@
 .SUFFIXES: .ml .mli .cmo .cmi .cmx
 
 .mli.cmi:
-	$(OCAMLC) -c $(COMPFLAGS) $<
+	$(CAMLC) -c $(COMPFLAGS) $<
 
 .ml.cmo:
-	$(OCAMLC) -c $(COMPFLAGS) $<
+	$(CAMLC) -c $(COMPFLAGS) $<
 
 .ml.cmx:
-	$(OCAMLOPT) -c $(COMPFLAGS) $<
+	$(CAMLOPT) -c $(COMPFLAGS) $<
 
 depend:
 
diff -urN ocaml-4.02.1-clean/otherlibs/systhreads/Makefile ocaml-4.02.1-ios/otherlibs/systhreads/Makefile
--- ocaml-4.02.1-clean/otherlibs/systhreads/Makefile	2014-10-03 16:25:00.000000000 +0400
+++ ocaml-4.02.1-ios/otherlibs/systhreads/Makefile	2014-10-29 12:47:20.000000000 +0300
@@ -13,12 +13,13 @@
 
 include ../../config/Makefile
 
-ROOTDIR=../..
-CAMLC=$(ROOTDIR)/boot/ocamlrun $(ROOTDIR)/ocamlc -nostdlib \
-      -I $(ROOTDIR)/stdlib -I $(ROOTDIR)/otherlibs/unix
-CAMLOPT=$(ROOTDIR)/boot/ocamlrun $(ROOTDIR)/ocamlopt -nostdlib \
-        -I $(ROOTDIR)/stdlib -I $(ROOTDIR)/otherlibs/unix
-MKLIB=../../boot/ocamlrun ../../tools/ocamlmklib
+CAMLC=ocamlc.opt -I ../unix
+CAMLOPT=../../ocamlopt.opt -I ../unix -nostdlib -I ../../stdlib
+MKLIB=../../tools/ocamlmklib
+COMPFLAGS=-w +33..39 -warn-error A -g
+
+BYTECODE_C_OBJS=st_stubs_b.o
+
 COMPFLAGS=-w +33..39 -warn-error A -g -bin-annot -safe-string
 
 BYTECODE_C_OBJS=st_stubs_b.o
@@ -64,7 +65,6 @@
 # modular to me this way. -- Alain
 
 
-$(THREAD_OBJS:.cmo=.cmx): ../../ocamlopt
 
 partialclean:
 	rm -f *.cm*
@@ -86,13 +86,17 @@
 	rm -f $(INSTALL_LIBDIR)/threads/stdlib.cma
 	cp thread.mli mutex.mli condition.mli event.mli threadUnix.mli \
 	   $(INSTALL_LIBDIR)
-	cp threads.h $(INSTALL_LIBDIR)/caml/threads.h
+	cp threads.h $(LIBDIR)/caml/threads.h
 
 installopt:
-	cp libthreadsnat.a $(INSTALL_LIBDIR)/libthreadsnat.a
-	cd $(INSTALL_LIBDIR); $(RANLIB) libthreadsnat.a
-	cp $(THREAD_OBJS:.cmo=.cmx) threads.cmxa threads.a $(INSTALL_LIBDIR)/threads
-	cd $(INSTALL_LIBDIR)/threads; $(RANLIB) threads.a
+	if test -d $(LIBDIR)/threads; then :; else mkdir $(LIBDIR)/threads; fi
+	cp $(THREAD_OBJS:.cmo=.cmi) $(LIBDIR)/threads
+	cp thread.mli mutex.mli condition.mli event.mli threadUnix.mli $(LIBDIR)
+	cp threads.h $(LIBDIR)/caml/threads.h
+	cp libthreadsnat.a $(LIBDIR)/libthreadsnat.a
+	cd $(LIBDIR); $(RANLIB) libthreadsnat.a
+	cp $(THREAD_OBJS:.cmo=.cmx) threads.cmxa threads.a $(LIBDIR)/threads
+
 
 .SUFFIXES: .ml .mli .cmo .cmi .cmx
 
diff -urN ocaml-4.02.1-clean/otherlibs/threads/pervasives.ml ocaml-4.02.1-ios/otherlibs/threads/pervasives.ml
--- ocaml-4.02.1-clean/otherlibs/threads/pervasives.ml	2014-05-27 10:10:47.000000000 +0400
+++ ocaml-4.02.1-ios/otherlibs/threads/pervasives.ml	2014-10-29 12:47:20.000000000 +0300
@@ -109,34 +109,34 @@
 external ( ~-. ) : float -> float = "%negfloat"
 external ( ~+. ) : float -> float = "%identity"
 external ( +. ) : float -> float -> float = "%addfloat"
-external ( -. ) : float -> float -> float = "%subfloat"
+external (-.) : float -> float -> float = "%subfloat"
 external ( *. ) : float -> float -> float = "%mulfloat"
-external ( /. ) : float -> float -> float = "%divfloat"
-external ( ** ) : float -> float -> float = "caml_power_float" "pow" "float"
-external exp : float -> float = "caml_exp_float" "exp" "float"
-external expm1 : float -> float = "caml_expm1_float" "caml_expm1" "float"
-external acos : float -> float = "caml_acos_float" "acos" "float"
-external asin : float -> float = "caml_asin_float" "asin" "float"
-external atan : float -> float = "caml_atan_float" "atan" "float"
-external atan2 : float -> float -> float = "caml_atan2_float" "atan2" "float"
+external (/.) : float -> float -> float = "%divfloat"
+external ( ** ) : float -> float -> float = "caml_power_float" (* "pow" "float" *)
+external exp : float -> float = "caml_exp_float" (* "exp" "float" *)
+external expm1 : float -> float = "caml_expm1_float" (* "caml_expm1" "float" *)
+external acos : float -> float = "caml_acos_float" (* "acos" "float" *)
+external asin : float -> float = "caml_asin_float" (* "asin" "float" *)
+external atan : float -> float = "caml_atan_float" (* "atan" "float" *)
+external atan2 : float -> float -> float = "caml_atan2_float" (* "atan2" "float" *)
 external hypot : float -> float -> float
-               = "caml_hypot_float" "caml_hypot" "float"
-external cos : float -> float = "caml_cos_float" "cos" "float"
-external cosh : float -> float = "caml_cosh_float" "cosh" "float"
-external log : float -> float = "caml_log_float" "log" "float"
-external log10 : float -> float = "caml_log10_float" "log10" "float"
-external log1p : float -> float = "caml_log1p_float" "caml_log1p" "float"
-external sin : float -> float = "caml_sin_float" "sin" "float"
-external sinh : float -> float = "caml_sinh_float" "sinh" "float"
-external sqrt : float -> float = "caml_sqrt_float" "sqrt" "float"
-external tan : float -> float = "caml_tan_float" "tan" "float"
-external tanh : float -> float = "caml_tanh_float" "tanh" "float"
-external ceil : float -> float = "caml_ceil_float" "ceil" "float"
-external floor : float -> float = "caml_floor_float" "floor" "float"
+   = "caml_hypot_float" (* "caml_hypot" "float" *)
+external cos : float -> float = "caml_cos_float" (* "cos" "float" *)
+external cosh : float -> float = "caml_cosh_float" (* "cosh" "float" *)
+external log : float -> float = "caml_log_float" (* "log" "float" *)
+external log10 : float -> float = "caml_log10_float" (* "log10" "float" *)
+external log1p : float -> float = "caml_log1p_float" (* "caml_log1p" "float" *)
+external sin : float -> float = "caml_sin_float" (* "sin" "float" *)
+external sinh : float -> float = "caml_sinh_float" (* "sinh" "float" *)
+external sqrt : float -> float = "caml_sqrt_float" (* "sqrt" "float" *)
+external tan : float -> float = "caml_tan_float" (* "tan" "float" *)
+external tanh : float -> float = "caml_tanh_float" (* "tanh" "float" *)
+external ceil : float -> float = "caml_ceil_float" (* "ceil" "float" *)
+external floor : float -> float = "caml_floor_float" (* "floor" "float" *)
 external abs_float : float -> float = "%absfloat"
 external copysign : float -> float -> float
-                  = "caml_copysign_float" "caml_copysign" "float"
-external mod_float : float -> float -> float = "caml_fmod_float" "fmod" "float"
+   = "caml_copysign_float" (* "caml_copysign" "float" *)
+external mod_float : float -> float -> float = "caml_fmod_float" (* "fmod" "float" *)
 external frexp : float -> float * int = "caml_frexp_float"
 external ldexp : float -> int -> float = "caml_ldexp_float"
 external modf : float -> float * float = "caml_modf_float"
diff -urN ocaml-4.02.1-clean/stdlib/Makefile ocaml-4.02.1-ios/stdlib/Makefile
--- ocaml-4.02.1-clean/stdlib/Makefile	2014-04-12 14:17:02.000000000 +0400
+++ ocaml-4.02.1-ios/stdlib/Makefile	2014-10-29 12:47:20.000000000 +0300
@@ -13,9 +13,7 @@
 
 include Makefile.shared
 
-allopt:
-	$(MAKE) stdlib.cmxa std_exit.cmx
-	$(MAKE) allopt-$(PROFILING)
+allopt: stdlib.cmxa std_exit.cmx camlheader camlheader_ur allopt-$(PROFILING)
 
 allopt-noprof:
 
@@ -25,7 +23,7 @@
 installopt: installopt-default installopt-$(PROFILING)
 
 installopt-default:
-	cp stdlib.cmxa stdlib.a std_exit.o *.cmx $(INSTALL_LIBDIR)
+	cp stdlib.cmxa stdlib.a std_exit.o *.cmx *.cmi *.mli *.ml camlheader camlheader_ur $(LIBDIR)
 	cd $(INSTALL_LIBDIR); $(RANLIB) stdlib.a
 
 installopt-noprof:
diff -urN ocaml-4.02.1-clean/stdlib/Makefile.shared ocaml-4.02.1-ios/stdlib/Makefile.shared
--- ocaml-4.02.1-clean/stdlib/Makefile.shared	2014-05-27 10:10:47.000000000 +0400
+++ ocaml-4.02.1-ios/stdlib/Makefile.shared	2014-10-29 12:47:20.000000000 +0300
@@ -12,14 +12,14 @@
 #########################################################################
 
 include ../config/Makefile
-RUNTIME=../boot/ocamlrun
-COMPILER=../ocamlc
-CAMLC=$(RUNTIME) $(COMPILER)
-COMPFLAGS=-strict-sequence -w +33..39 -g -warn-error A -bin-annot -nostdlib \
-          -safe-string
-OPTCOMPILER=../ocamlopt
-CAMLOPT=$(RUNTIME) $(OPTCOMPILER)
-CAMLDEP=../boot/ocamlrun ../tools/ocamldep
+RUNTIME=ocamlrun
+CAMLC=ocamlc.opt
+COMPFLAGS=-strict-sequence -w +33..39 -g -warn-error A -nostdlib
+CAMLOPT=../ocamlopt.opt
+OPTCOMPFLAGS=-warn-error A -nostdlib -g
+CAMLDEP=ocamldep.opt
+
+
 
 OBJS=camlinternalFormatBasics.cmo pervasives.cmo $(OTHERS)
 OTHERS=array.cmo list.cmo char.cmo bytes.cmo string.cmo sys.cmo \
@@ -79,7 +79,7 @@
 	$(CAMLOPT) $(COMPFLAGS) `./Compflags $@` -c $<
 
 .ml.p.cmx:
-	$(CAMLOPT) $(COMPFLAGS) `./Compflags $@` -p -c -o $*.p.cmx $<
+	$(CAMLOPT) $(OPTCOMPFLAGS) `./Compflags $@` -p -c -o $*.p.cmx $<
 
 # Dependencies on the compiler
 $(OBJS) std_exit.cmo: $(COMPILER)
@@ -88,7 +88,8 @@
 $(OBJS:.cmo=.p.cmx) std_exit.p.cmx: $(OPTCOMPILER)
 
 # Dependencies on Pervasives (not tracked by ocamldep)
-$(OTHERS) std_exit.cmo: pervasives.cmi
+$(OBJS) std_exit.cmo: pervasives.cmi
+
 $(OTHERS:.cmo=.cmi) std_exit.cmi: pervasives.cmi
 $(OBJS:.cmo=.cmx) std_exit.cmx: pervasives.cmi
 $(OBJS:.cmo=.p.cmx) std_exit.p.cmx: pervasives.cmi
diff -urN ocaml-4.02.1-clean/stdlib/camlinternalOO.ml ocaml-4.02.1-ios/stdlib/camlinternalOO.ml
--- ocaml-4.02.1-clean/stdlib/camlinternalOO.ml	2014-08-18 22:26:49.000000000 +0400
+++ ocaml-4.02.1-ios/stdlib/camlinternalOO.ml	2014-10-29 12:47:20.000000000 +0300
@@ -68,17 +68,14 @@
 
 let public_method_label s : tag =
   let accu = ref 0 in
-  for i = 0 to String.length s - 1 do
-    accu := 223 * !accu + Char.code s.[i]
-  done;
-  (* reduce to 31 bits *)
-  accu := !accu land (1 lsl 31 - 1);
-  (* make it signed for 64 bits architectures *)
-  let tag = if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu in
-  (* Printf.eprintf "%s = %d\n" s tag; flush stderr; *)
-  magic tag
+   for i = 0 to String.length s - 1 do
+     accu := 223 * !accu + Char.code s.[i]
+   done;
+  let tag = !accu land (1 lsl 31 - 1) in
+   magic tag
+
+ (**** Sparse array ****)
 
-(**** Sparse array ****)
 
 module Vars =
   Map.Make(struct type t = string let compare (x:t) y = compare x y end)
diff -urN ocaml-4.02.1-clean/stdlib/hashtbl.ml ocaml-4.02.1-ios/stdlib/hashtbl.ml
--- ocaml-4.02.1-clean/stdlib/hashtbl.ml	2013-03-10 02:38:52.000000000 +0400
+++ ocaml-4.02.1-ios/stdlib/hashtbl.ml	2014-10-29 12:47:20.000000000 +0300
@@ -132,7 +132,8 @@
       if compare key k = 0 then d else find_rec key rest
 
 let find h key =
-  match h.data.(key_index h key) with
+  let i = key_index h key in
+  match h.data.(i) with
   | Empty -> raise Not_found
   | Cons(k1, d1, rest1) ->
       if compare key k1 = 0 then d1 else
diff -urN ocaml-4.02.1-clean/stdlib/pervasives.ml ocaml-4.02.1-ios/stdlib/pervasives.ml
--- ocaml-4.02.1-clean/stdlib/pervasives.ml	2014-08-05 19:33:26.000000000 +0400
+++ ocaml-4.02.1-ios/stdlib/pervasives.ml	2014-10-29 12:47:20.000000000 +0300
@@ -97,8 +97,8 @@
 external ( lsr ) : int -> int -> int = "%lsrint"
 external ( asr ) : int -> int -> int = "%asrint"
 
-let max_int = (-1) lsr 1
-let min_int = max_int + 1
+let min_int = 1 lsl 30
+let max_int = min_int - 1
 
 (* Floating-point operations *)
 
@@ -109,30 +109,31 @@
 external ( *. ) : float -> float -> float = "%mulfloat"
 external ( /. ) : float -> float -> float = "%divfloat"
 external ( ** ) : float -> float -> float = "caml_power_float" "pow" "float"
-external exp : float -> float = "caml_exp_float" "exp" "float"
-external expm1 : float -> float = "caml_expm1_float" "caml_expm1" "float"
-external acos : float -> float = "caml_acos_float" "acos" "float"
-external asin : float -> float = "caml_asin_float" "asin" "float"
-external atan : float -> float = "caml_atan_float" "atan" "float"
-external atan2 : float -> float -> float = "caml_atan2_float" "atan2" "float"
+external ( ** ) : float -> float -> float = "caml_power_float" (* "pow" "float" *)
+external exp : float -> float = "caml_exp_float" (* "exp" "float" *)
+external expm1 : float -> float = "caml_expm1_float" (* "caml_expm1" "float" *)
+external acos : float -> float = "caml_acos_float" (* "acos" "float" *)
+external asin : float -> float = "caml_asin_float" (* "asin" "float" *)
+external atan : float -> float = "caml_atan_float" (* "atan" "float" *)
+external atan2 : float -> float -> float = "caml_atan2_float" (* "atan2" "float" *)
 external hypot : float -> float -> float
-               = "caml_hypot_float" "caml_hypot" "float"
-external cos : float -> float = "caml_cos_float" "cos" "float"
-external cosh : float -> float = "caml_cosh_float" "cosh" "float"
-external log : float -> float = "caml_log_float" "log" "float"
-external log10 : float -> float = "caml_log10_float" "log10" "float"
-external log1p : float -> float = "caml_log1p_float" "caml_log1p" "float"
-external sin : float -> float = "caml_sin_float" "sin" "float"
-external sinh : float -> float = "caml_sinh_float" "sinh" "float"
-external sqrt : float -> float = "caml_sqrt_float" "sqrt" "float"
-external tan : float -> float = "caml_tan_float" "tan" "float"
-external tanh : float -> float = "caml_tanh_float" "tanh" "float"
-external ceil : float -> float = "caml_ceil_float" "ceil" "float"
-external floor : float -> float = "caml_floor_float" "floor" "float"
+               = "caml_hypot_float" (* "caml_hypot" "float" *)
+external cos : float -> float = "caml_cos_float" (* "cos" "float" *)
+external cosh : float -> float = "caml_cosh_float" (* "cosh" "float" *)
+external log : float -> float = "caml_log_float" (* "log" "float" *)
+external log10 : float -> float = "caml_log10_float" (* "log10" "float" *)
+external log1p : float -> float = "caml_log1p_float" (* "caml_log1p" "float" *)
+external sin : float -> float = "caml_sin_float" (* "sin" "float" *)
+external sinh : float -> float = "caml_sinh_float" (* "sinh" "float" *)
+external sqrt : float -> float = "caml_sqrt_float" (* "sqrt" "float" *)
+external tan : float -> float = "caml_tan_float" (* "tan" "float" *)
+external tanh : float -> float = "caml_tanh_float" (* "tanh" "float" *)
+external ceil : float -> float = "caml_ceil_float" (* "ceil" "float" *)
+external floor : float -> float = "caml_floor_float" (* "floor" "float" *)
 external abs_float : float -> float = "%absfloat"
 external copysign : float -> float -> float
-                  = "caml_copysign_float" "caml_copysign" "float"
-external mod_float : float -> float -> float = "caml_fmod_float" "fmod" "float"
+                  = "caml_copysign_float" (* "caml_copysign" "float" *)
+external mod_float : float -> float -> float = "caml_fmod_float" (* "fmod" "float" *)
 external frexp : float -> float * int = "caml_frexp_float"
 external ldexp : float -> int -> float = "caml_ldexp_float"
 external modf : float -> float * float = "caml_modf_float"
diff -urN ocaml-4.02.1-clean/stdlib/pervasives.mli ocaml-4.02.1-ios/stdlib/pervasives.mli
--- ocaml-4.02.1-clean/stdlib/pervasives.mli	2014-09-14 23:41:26.000000000 +0400
+++ ocaml-4.02.1-ios/stdlib/pervasives.mli	2014-10-29 12:47:20.000000000 +0300
@@ -318,82 +318,82 @@
 external ( /. ) : float -> float -> float = "%divfloat"
 (** Floating-point division. *)
 
-external ( ** ) : float -> float -> float = "caml_power_float" "pow" "float"
+external ( ** ) : float -> float -> float = "caml_power_float" (*"pow" "float"*)
 (** Exponentiation. *)
 
-external sqrt : float -> float = "caml_sqrt_float" "sqrt" "float"
+external sqrt : float -> float = "caml_sqrt_float" (*"sqrt" "float"*)
 (** Square root. *)
 
-external exp : float -> float = "caml_exp_float" "exp" "float"
+external exp : float -> float = "caml_exp_float" (*"exp" "float"*)
 (** Exponential. *)
 
-external log : float -> float = "caml_log_float" "log" "float"
+external log : float -> float = "caml_log_float" (*"log" "float"*)
 (** Natural logarithm. *)
 
-external log10 : float -> float = "caml_log10_float" "log10" "float"
+external log10 : float -> float = "caml_log10_float" (*"log10" "float"*)
 (** Base 10 logarithm. *)
 
-external expm1 : float -> float = "caml_expm1_float" "caml_expm1" "float"
+external expm1 : float -> float = "caml_expm1_float" (*"caml_expm1" "float"*)
 (** [expm1 x] computes [exp x -. 1.0], giving numerically-accurate results
     even if [x] is close to [0.0].
     @since 3.12.0
 *)
 
-external log1p : float -> float = "caml_log1p_float" "caml_log1p" "float"
+external log1p : float -> float = "caml_log1p_float" (*"caml_log1p" "float"*)
 (** [log1p x] computes [log(1.0 +. x)] (natural logarithm),
     giving numerically-accurate results even if [x] is close to [0.0].
     @since 3.12.0
 *)
 
-external cos : float -> float = "caml_cos_float" "cos" "float"
+external cos : float -> float = "caml_cos_float" (*"cos" "float"*)
 (** Cosine.  Argument is in radians. *)
 
-external sin : float -> float = "caml_sin_float" "sin" "float"
+external sin : float -> float = "caml_sin_float" (*"sin" "float"*)
 (** Sine.  Argument is in radians. *)
 
-external tan : float -> float = "caml_tan_float" "tan" "float"
+external tan : float -> float = "caml_tan_float" (*"tan" "float"*)
 (** Tangent.  Argument is in radians. *)
 
-external acos : float -> float = "caml_acos_float" "acos" "float"
+external acos : float -> float = "caml_acos_float" (*"acos" "float"*)
 (** Arc cosine.  The argument must fall within the range [[-1.0, 1.0]].
     Result is in radians and is between [0.0] and [pi]. *)
 
-external asin : float -> float = "caml_asin_float" "asin" "float"
+external asin : float -> float = "caml_asin_float" (*"asin" "float"*)
 (** Arc sine.  The argument must fall within the range [[-1.0, 1.0]].
     Result is in radians and is between [-pi/2] and [pi/2]. *)
 
-external atan : float -> float = "caml_atan_float" "atan" "float"
+external atan : float -> float = "caml_atan_float" (*"atan" "float"*)
 (** Arc tangent.
     Result is in radians and is between [-pi/2] and [pi/2]. *)
 
-external atan2 : float -> float -> float = "caml_atan2_float" "atan2" "float"
+external atan2 : float -> float -> float = "caml_atan2_float" (*"atan2" "float"*)
 (** [atan2 y x] returns the arc tangent of [y /. x].  The signs of [x]
     and [y] are used to determine the quadrant of the result.
     Result is in radians and is between [-pi] and [pi]. *)
 
 external hypot : float -> float -> float
-               = "caml_hypot_float" "caml_hypot" "float"
+               = "caml_hypot_float" (*"caml_hypot" "float"*)
 (** [hypot x y] returns [sqrt(x *. x + y *. y)], that is, the length
   of the hypotenuse of a right-angled triangle with sides of length
   [x] and [y], or, equivalently, the distance of the point [(x,y)]
   to origin.
   @since 4.00.0  *)
 
-external cosh : float -> float = "caml_cosh_float" "cosh" "float"
+external cosh : float -> float = "caml_cosh_float" (*"cosh" "float"*)
 (** Hyperbolic cosine.  Argument is in radians. *)
 
-external sinh : float -> float = "caml_sinh_float" "sinh" "float"
+external sinh : float -> float = "caml_sinh_float" (*"sinh" "float"*)
 (** Hyperbolic sine.  Argument is in radians. *)
 
-external tanh : float -> float = "caml_tanh_float" "tanh" "float"
+external tanh : float -> float = "caml_tanh_float" (*"tanh" "float"*)
 (** Hyperbolic tangent.  Argument is in radians. *)
 
-external ceil : float -> float = "caml_ceil_float" "ceil" "float"
+external ceil : float -> float = "caml_ceil_float" (*"ceil" "float"*)
 (** Round above to an integer value.
     [ceil f] returns the least integer value greater than or equal to [f].
     The result is returned as a float. *)
 
-external floor : float -> float = "caml_floor_float" "floor" "float"
+external floor : float -> float = "caml_floor_float" (*"floor" "float"*)
 (** Round below to an integer value.
     [floor f] returns the greatest integer value less than or
     equal to [f].
@@ -403,14 +403,14 @@
 (** [abs_float f] returns the absolute value of [f]. *)
 
 external copysign : float -> float -> float
-                  = "caml_copysign_float" "caml_copysign" "float"
+                  = "caml_copysign_float" (*"caml_copysign" "float"*)
 (** [copysign x y] returns a float whose absolute value is that of [x]
   and whose sign is that of [y].  If [x] is [nan], returns [nan].
   If [y] is [nan], returns either [x] or [-. x], but it is not
   specified which.
   @since 4.00.0  *)
 
-external mod_float : float -> float -> float = "caml_fmod_float" "fmod" "float"
+external mod_float : float -> float -> float = "caml_fmod_float" (*"fmod" "float"*)
 (** [mod_float a b] returns the remainder of [a] with respect to
    [b].  The returned value is [a -. n *. b], where [n]
    is the quotient [a /. b] rounded towards zero to an integer. *)
diff -urN ocaml-4.02.1-clean/tools/Makefile.shared ocaml-4.02.1-ios/tools/Makefile.shared
--- ocaml-4.02.1-clean/tools/Makefile.shared	2014-08-07 12:52:02.000000000 +0400
+++ ocaml-4.02.1-ios/tools/Makefile.shared	2014-10-29 12:47:20.000000000 +0300
@@ -12,13 +12,13 @@
 
 include ../config/Makefile
 
-CAMLRUN=../boot/ocamlrun
-CAMLC=$(CAMLRUN) ../boot/ocamlc -nostdlib -I ../boot
-CAMLOPT=$(CAMLRUN) ../ocamlopt -nostdlib -I ../stdlib
-CAMLLEX=$(CAMLRUN) ../boot/ocamllex
+CAMLRUN=ocamlrun
+CAMLC=ocamlc.opt -strict-sequence -I ../boot
+CAMLOPT=ocamlopt.opt
+CAMLLEX=ocamllex
 INCLUDES=-I ../utils -I ../parsing -I ../typing -I ../bytecomp -I ../asmcomp \
-	 -I ../driver -I ../toplevel
-COMPFLAGS= -strict-sequence -w +27+32..39 -warn-error A -safe-string $(INCLUDES)
+ 	 -I ../driver
+COMPFLAGS= -w +32..39 -warn-error A $(INCLUDES)
 LINKFLAGS=$(INCLUDES)
 
 all: ocamldep ocamlprof ocamlcp ocamloptp ocamlmktop ocamlmklib dumpobj \
Binary files ocaml-4.02.1-clean/tools/cvt_emit.bak and ocaml-4.02.1-ios/tools/cvt_emit.bak differ
